<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.0">
    <TriggerPackage>
        <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>NameDB</name>
            <script></script>
            <triggerType>0</triggerType>
            <conditonLineDelta>99</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList/>
            <regexCodePropertyList/>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Data Capture</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Lists</name>
                    <script></script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList/>
                    <regexCodePropertyList/>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>NameDB cwho</name>
                        <script>temp_name_list = {}
temp_demigod = 0
ndb.temp_classes_list = {}

local lastline = getLines(getLineNumber()-1, getLineNumber())[1]

ndb.temp_cwho = {
  rank = lastline:find(&quot;Rank&quot;),
  position = lastline:find(&quot;Position&quot;),
  ct = lastline:find(&quot;CT&quot;),
}</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>1</conditonLineDelta>
                        <mStayOpen>100</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>^(?:Commune Member|Citizen)</string>
                            <string>Rank</string>
                            <string>Position</string>
                            <string>CT</string>
                            <string>-------------------------------------------------</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>1</integer>
                            <integer>0</integer>
                            <integer>0</integer>
                            <integer>0</integer>
                            <integer>0</integer>
                        </regexCodePropertyList>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Get name (cwho)</name>
                            <script>local line = line

local name = line:match(&quot;^(%w+)&quot;)
local rank = line:sub(ndb.temp_cwho.rank, ndb.temp_cwho.position-1):trim()
local position = line:sub(ndb.temp_cwho.position-1, ndb.temp_cwho.ct-1):trim()

resetFormat()

temp_name_list[#temp_name_list + 1] = {
  name = name,
  org_rank = ndb.getorgrank(rank),
  org = ndb.getmyorg()
}

-- if we know their class, add it in
-- the max class name length is 12

local class = ndb.getclass(name)
local demigod
if ndb.isdemigod then demigod = ndb.isdemigod(name) end

local moveback = (#line &gt;= 89 and 5 or 2)
if class and class ~= &quot;&quot; then
	moveCursor(ndb.temp_cwho.rank - moveback, getLineNumber())
	fg(&quot;a_darkwhite&quot;)
	if demigod then fg(&quot;DarkSlateGrey&quot;) insertText(&quot;(h)&quot;) fg(&quot;a_darkwhite&quot;); temp_demigod = temp_demigod + 1 end
	insertText(class)

	-- delete extra spaces that got shifted over now
	if selectString((&quot; &quot;):rep(#class + (demigod and 3 or 0)), 1) &gt; 0 then replace(&quot;&quot;) end
	ndb.temp_classes_list[class] = (ndb.temp_classes_list[class] or 0) + 1

elseif demigod then
	moveCursor(ndb.temp_cwho.rank - moveback, getLineNumber())
	fg(&quot;DarkSlateGrey&quot;) insertText(&quot;(h)&quot;)
    temp_demigod = temp_demigod + 1
	if selectString((&quot; &quot;):rep(3), 1) &gt; 0 then replace(&quot;&quot;) end
end</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>return not isPrompt() and not line:starts(&quot;-&quot;) and not line:starts(&quot;*&quot;) and not line:starts(&quot;Currently, there&quot;)</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>4</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Stop getting (cwho)</name>
                            <script>setTriggerStayOpen(&quot;NameDB cwho&quot;, 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent(&quot;NameDB saw list name&quot;, person.name)
end

if next(ndb.temp_classes_list) then
  local classes = mm.keystolist(ndb.temp_classes_list)
  table.sort(classes)

  for i = 1, #classes do
    classes[i] = ndb.temp_classes_list[classes[i]] .. &quot; &quot;..(ndb.temp_classes_list[classes[i]] == 1 and classes[i] or string.pluralize(classes[i]))
  end

  moveCursor(0, getLineNumber())
  mm.itf(&quot;%s present, of those %s %s demigod%s/ascendant%s.\n&quot;, mm.concatand(classes), temp_demigod, (temp_demigod == 1 and 'is a' or 'are'), (temp_demigod == 1 and '' or 's'), (temp_demigod == 1 and '' or 's'))
  moveCursorEnd()
  ndb.temp_classes_list = nil
end


temp_name_list = nil
ndb.temp_cwho = nil

raiseEvent(&quot;NameDB got new data&quot;)</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>Currently, there</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>2</integer>
                            </regexCodePropertyList>
                        </Trigger>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>NameDB gwho</name>
                        <script>temp_name_list = {}</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>1</conditonLineDelta>
                        <mStayOpen>100</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>Guildmember</string>
                            <string>Rank</string>
                            <string>Position</string>
                            <string>GT</string>
                            <string>GNT</string>
                            <string>CGT</string>
                            <string>----------------------------</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>2</integer>
                            <integer>0</integer>
                            <integer>0</integer>
                            <integer>0</integer>
                            <integer>0</integer>
                            <integer>0</integer>
                            <integer>2</integer>
                        </regexCodePropertyList>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Get name (gwho)</name>
                            <script>temp_name_list[#temp_name_list + 1] = {
  name = multimatches[1][2],
  guild = ndb.findfromtable(gmcp.Char.Status.guild, ndb.valid.guilds)
}

temp_name_list[#temp_name_list].class = ndb.valid.guildtoclass[temp_name_list[#temp_name_list].guild]</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>^(\w+)</string>
                                <string>return not line:find(&quot;^Currently&quot;)</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                                <integer>4</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Stop getting (gwho)</name>
                            <script>setTriggerStayOpen(&quot;NameDB gwho&quot;, 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent(&quot;NameDB saw list name&quot;, person.name)
end

temp_name_list = nil

raiseEvent(&quot;NameDB got new data&quot;)</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>return isPrompt()</string>
                                <string>Currently,</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>4</integer>
                                <integer>2</integer>
                            </regexCodePropertyList>
                        </Trigger>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Citizens/Members</name>
                        <script>local templist = string.split(multimatches[3][1], &quot;,&quot;)

for i,k in pairs(templist) do
	templist[i] = k:trim()
end

-- last on name on list might have a dot
if string.sub(templist[#templist], -1, -1) == &quot;.&quot; then
	templist[#templist] = string.sub(templist[#templist], 1, -2)
end

ndb.tempnames = nil

local temp_name_list = {}

for i,j in ipairs(templist) do
	temp_name_list[#temp_name_list + 1] = {
		name = j,
		org = ndb.getmyorg()
	}
end

db:merge_unique(ndb.db.people, temp_name_list)

raiseEvent(&quot;NameDB got new data&quot;)

-- reload all highlights, as citizens list is big anyhow
ndb.loadhighlights()</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>1</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>^The following are ACTIVE (?:citizens|commune members) of .+\:$</string>
                            <string>1</string>
                            <string>.+</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>1</integer>
                            <integer>5</integer>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Guild members</name>
                        <script>temp_name_list = {}

-- this can't be used: no name highlighting in the list done by Lusternia</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>999</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>  GR Status Name + Title</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>2</integer>
                        </regexCodePropertyList>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Get name (guild members)</name>
                            <script>local match = getColorWildcard(14)

if match then
  if matches[2]:lower() == &quot;demigod&quot; then matches[2] = nil end

  temp_name_list[#temp_name_list + 1] = {
    name = match[1],
    class = ((matches[2] and ndb.isvalidclass(matches[2])) and matches[2]:lower() or &quot;&quot;),
    guild = ndb.findfromtable(gmcp.Char.Status.guild, ndb.valid.guilds)
  }
end</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>^ *\d+(?: prob)? +(\w+)\s+.*$</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Stop getting (guild members)</name>
                            <script>setTriggerStayOpen(&quot;Guild members&quot;, 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent(&quot;NameDB saw list name&quot;, person.name)
end

temp_name_list = nil

raiseEvent(&quot;NameDB got new data&quot;)</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>^\d+</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Order members</name>
                        <script>temp_name_list = {}</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>2</conditonLineDelta>
                        <mStayOpen>300</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>*******</string>
                            <string>[ THE DIVINE ORDER OF</string>
                            <string>Faithful</string>
                            <string>--------</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>2</integer>
                            <integer>0</integer>
                            <integer>2</integer>
                            <integer>0</integer>
                        </regexCodePropertyList>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Member</name>
                            <script>if matches[2] == &quot;Type&quot; or matches[2] == &quot;There&quot; or matches[2] == &quot;You&quot; then return end

temp_name_list[#temp_name_list + 1] = {
  name = matches[2],
  order = gmcp.Char.Status.order:match(&quot;^(%w+)&quot;)
}</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>^([A-Za-z]+)\*?</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Update list on break</name>
                            <script>db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent(&quot;NameDB saw list name&quot;, person.name)
end

temp_name_list = {}

raiseEvent(&quot;NameDB got new data&quot;)</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>Type MORE to continue reading.</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>2</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Member list stop</name>
                            <script>setTriggerStayOpen(&quot;Order members&quot;, 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent(&quot;NameDB saw list name&quot;, person.name)
end

temp_name_list = nil

raiseEvent(&quot;NameDB got new data&quot;)</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>^There are \w+ faithful in the Order\.$</string>
                                <string>return isPrompt()</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                                <integer>4</integer>
                            </regexCodePropertyList>
                        </Trigger>
                    </Trigger>
                    <Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>NameDB qw</name>
                        <script>-- ignore yourself gemmed offplane
if multimatches[1][1] == &quot;None.&quot; or multimatches[1][1] == &quot;You can not sense a single person&quot; then return end

-- all data is on the previous line
local data = multimatches[1][1]
data = string.split(data, &quot;, &quot;)

-- fix last name that ends with a dot
data[#data] = string.sub(data[#data], 1, #data[#data] - 1)

-- fix the 'and Name' from qw2
if data[#data]:starts(&quot;and &quot;) then
  data[#data] = data[#data]:match(&quot;and (%w+)&quot;)
end

local temp_name_list = {}

for i = 1, #data do
  local name = data[i]
  -- check for guides
  if name:find(&quot;(&quot;, 1, true) then
    local secondname
    name, secondname = name:match(&quot;(%w+)%((%w+)%)&quot;)
	
    -- guides are in the format of Name(Name), some non-guides are just (Name)
    if secondname then temp_name_list[#temp_name_list + 1] = {name = secondname} end

    -- handle just (Name)
    if not name then name = data[i]:match(&quot;%((%w+)%)&quot;) end
  end

  temp_name_list[#temp_name_list + 1] = {name = name}
end

-- re-honors if asked for
if ndb.qwtype and ndb.qwtype == &quot;update&quot; then
  for _, name in pairs(temp_name_list) do
    name.might = -1
  end

-- or organize by orgs
elseif ndb.qwtype and ndb.qwtype == &quot;organize orgs&quot; then
  local orgs = {}

  local getorg = ndb.getorg
  for _, person in pairs(temp_name_list) do
    local org = getorg(person.name)

    org = org or &quot;unknown&quot;
    if org == &quot;&quot; then org = &quot;rogue&quot; end

    if ndb.isimmortal(person.name) then org = &quot;Immortal&quot; end

    orgs[org] = orgs[org] or {}
    orgs[org][#orgs[org]+1] = person.name
  end

  echo'\n\n'
  mm.echof(&quot;qw, sorted by members and count:&quot;)

  local sortbycount, longestorgname = {}, 0
  for org, members in pairs(orgs) do
    sortbycount[org] = #members
    if #org &gt; longestorgname then longestorgname = #org end
  end

  local sortbycount = {}; for org in pairs(orgs) do sortbycount[#sortbycount+1] = {org, #orgs[org]} end
  table.sort(sortbycount, function(a, b)
    return a[2] &gt; b[2]
  end)

  for _, org in ipairs(sortbycount) do
    local org, members = org[1], orgs[org[1]]
    table.sort(members)
    cecho(string.format(&quot;  &lt;royal_blue&gt;%-&quot;..longestorgname..&quot;s&lt;a_grey&gt; &lt;DarkSlateGrey&gt;(&lt;blaze_orange&gt;%d&lt;DarkSlateGrey&gt;): &lt;a_grey&gt;%s\n&quot;, org, #members, mm.concatand(members)))
  end

-- or report to cc
elseif ndb.qwtype and ndb.qwtype:starts(&quot;report members of &quot;) then
  local wanted = ndb.qwtype:match(&quot;^report members of (%w+)&quot;):lower()

  local citizens = {}
  for _, org in ipairs(ndb.valid.orgs) do
    if org:lower():starts(wanted) then
      wanted = org

      for _, person in pairs(temp_name_list) do
        local persons_org = ndb.getorg(person.name)
        if persons_org == org then citizens[#citizens+1] = person.name end
      end

      break
    end
  end

  if not citizens[1] then echo'\n' mm.echof(&quot;No citizens of %s seem to be on.&quot;, wanted) return end

  table.sort(citizens)

  mm.cc(&quot;%s %s visible: %s&quot;, #citizens, ndb.getpluralorg(wanted, #citizens), mm.concatand(citizens))
end

db:merge_unique(ndb.db.people, temp_name_list)

raiseEvent(&quot;NameDB got new data&quot;)
disableTrigger(&quot;NameDB qw&quot;)</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>1</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>.*</string>
                            <string>1</string>
                            <string>^(?:\(\*\) Currently, there are|There are)</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>1</integer>
                            <integer>5</integer>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="yes" isColorTriggerBg="yes">
                        <name>Org/Guild/Order enemies</name>
                        <script>local field

if ndb.checkingenemies.command == &quot;commune&quot; or ndb.checkingenemies.command == &quot;city&quot; then
  ndb.fixed_set(ndb.db.people.orgenemy, 0)
  field = &quot;org&quot;
elseif multimatches[2][1]:find(&quot;Order&quot;) then
  ndb.fixed_set(ndb.db.people.orderenemy, 0)
  field = &quot;order&quot;
elseif multimatches[2][1]:find(&quot;Guild&quot;) then
  ndb.fixed_set(ndb.db.people.guildenemy, 0)
  field = &quot;guild&quot;
else
  mm.echof(&quot;Hm, problem - can't work out which orgs enemies are you looking at.&quot;)
end

local names = string.split(multimatches[4][1], &quot;,&quot;)

for i = 1, #names do
  names[i] = names[i]:trim()
end

ndb.fixed_set(ndb.db.people[field..&quot;enemy&quot;], 1, db:in_(ndb.db.people.name, names))

-- reload all highlights
ndb.loadhighlights()

echo'\n'

if ndb.checkingenemies and ndb.checkingenemies.option then
  local temp_name_list = {}
  for i = 1, #names do
    temp_name_list[#temp_name_list + 1] = {
      name = names[i],
    }
  end

  db:merge_unique(ndb.db.people, temp_name_list)

  mm.echof(field:title()..&quot; enemies list updated, and new names added.&quot;)

  raiseEvent(&quot;NameDB got new data&quot;)
else
  mm.echof(field:title()..&quot; enemies list updated.&quot;)
end

disableTrigger(&quot;Org/Guild/Order enemies&quot;)
if ndb.checkingenemies then killTimer(ndb.checkingenemies[1]) end
ndb.checkingenemies = nil</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>3</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#00b300</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>Enemies of the </string>
                            <string>FG6BG2</string>
                            <string>1</string>
                            <string>.+</string>
                            <string>1</string>
                            <string>Total:</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>2</integer>
                            <integer>6</integer>
                            <integer>5</integer>
                            <integer>1</integer>
                            <integer>5</integer>
                            <integer>2</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Birthdays list</name>
                        <script>-- this can't be used: no name highlighting in the list done by Lusternia

bdayTable = bdayTable or {}
bdayTable[#bdayTable+1] = matches[2]

mm.prompttrigger(&quot;namedb capture birtdhdays&quot;, function()
	local temp_name_list = {}

	for i,j in ipairs(bdayTable) do
		temp_name_list[#temp_name_list + 1] = {
			name = j
		}
	end

	db:merge_unique(ndb.db.people, temp_name_list)

	raiseEvent(&quot;NameDB got new data&quot;)
	bdayTable = nil
end)</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>^(\w+) is \d+ years old today!$</string>
                            <string>^The soul of (\w+) is \d+ years old today!$</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>1</integer>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>ClairSentience</name>
                        <script>temp_name_list = {}</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>20</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>You gently coax the wind into telling you its secrets, and attempt to discern the locations of other Ascendants:</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                        </regexCodePropertyList>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Ascendant</name>
                            <script>temp_name_list[#temp_name_list + 1] = {name = matches[2]}</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>^You distantly sense (\w+)</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>End (ClairSentience)</name>
                            <script>setTriggerStayOpen(&quot;ClairSentience&quot;, 0)

db:merge_unique(ndb.db.people, temp_name_list)

temp_name_list = nil

raiseEvent(&quot;NameDB got new data&quot;)</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>return isPrompt()</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>4</integer>
                            </regexCodePropertyList>
                        </Trigger>
                    </Trigger>
                    <Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Allies/enemies list (namedb)</name>
                        <script>temp_name_list = {}</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>999</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>You consider the following adventurers your allies:</string>
                            <string>You consider the following adventurers your enemies:</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                            <integer>3</integer>
                        </regexCodePropertyList>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Person</name>
                            <script>temp_name_list[#temp_name_list + 1] = {name = matches[2]}</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>^You feel an unusually strong lust for (\w+)\.$</string>
                                <string>^(\w+) is an ally\.$</string>
                                <string>^(\w+) is an enemy\.$</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                                <integer>1</integer>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Stop (allies list)</name>
                            <script>setTriggerStayOpen(&quot;Allies/enemies list (namedb)&quot;, 0)

db:merge_unique(ndb.db.people, temp_name_list)

temp_name_list = nil

raiseEvent(&quot;NameDB got new data&quot;)</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>return isPrompt()</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>4</integer>
                            </regexCodePropertyList>
                        </Trigger>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Scent (namedb)</name>
                        <script>temp_name_list = {}</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>999</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>You scent at the air, your skilled nose picking up the faint traces of others in the surrounding area.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                        </regexCodePropertyList>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Person</name>
                            <script>temp_name_list[#temp_name_list + 1] = {name = matches[2]}</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>^You make out the scent of (\w+)</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>End (scent)</name>
                            <script>setTriggerStayOpen(&quot;Scent (namedb)&quot;, 0)

db:merge_unique(ndb.db.people, temp_name_list)

temp_name_list = nil

raiseEvent(&quot;NameDB got new data&quot;)</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>return isPrompt()</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>4</integer>
                            </regexCodePropertyList>
                        </Trigger>
                    </Trigger>
                </TriggerGroup>
                <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Various common things</name>
                    <script></script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList/>
                    <regexCodePropertyList/>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Channel history</name>
                        <script>ndb.temp_name_list = {}</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>1000</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>Most recent communication for the</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>2</integer>
                        </regexCodePropertyList>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>A line</name>
                            <script>if matches[2] ~= &quot;Someone&quot; then
  ndb.temp_name_list[#ndb.temp_name_list + 1] = {
    name = matches[2]
  }
end</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>^\d+ ?\) (\w+)</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>End (channel history)</name>
                            <script>setTriggerStayOpen(&quot;Channel history&quot;, 0)

db:merge_unique(ndb.db.people, ndb.temp_name_list)

ndb.temp_name_list = nil

raiseEvent(&quot;NameDB got new data&quot;)</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>return isPrompt()</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>4</integer>
                            </regexCodePropertyList>
                        </Trigger>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Newbie spawned - guild fledglings</name>
                        <script>local temp_name_list = temp_name_list or {}

temp_name_list[#temp_name_list + 1] = {
  name = multimatches[2][2],
  org = ndb.getmyorg()
}

db:merge_unique(ndb.db.people, temp_name_list)

mm.prompttrigger(&quot;new data, don't erase line&quot;, function() raiseEvent(&quot;NameDB got new data&quot;) end)</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>(Fledglings): Please welcome</string>
                            <string>^\(Fledglings\): Please welcome (\w+) who has graduated from .+ and joins as a novice freshman\!</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>2</integer>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Newbie spawned - city</name>
                        <script>local temp_name_list = temp_name_list or {}

temp_name_list[#temp_name_list + 1] = {
  name = multimatches[2][2],
  org = ndb.getmyorg()
}

db:merge_unique(ndb.db.people, temp_name_list)

mm.prompttrigger(&quot;new data, don't erase line&quot;, function() raiseEvent(&quot;NameDB got new data&quot;) end)</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>(</string>
                            <string>^\(\w+\): Please welcome (\w+) who just stepped out of the Portal of Fate as a new commune member!$</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>2</integer>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Citizened a person</name>
                        <script>local name = multimatches[2][2]

db:merge_unique(ndb.db.people, {{
  name = name,
  org = ndb.getmyorg(),
  org_rank = 1,
}})

mm.prompttrigger(&quot;new data, don't erase line&quot;, function() raiseEvent(&quot;NameDB got new data&quot;) end)
</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>You ask</string>
                            <string>^You ask (\w+) to repeat the oaths of .+ after you\.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>2</integer>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Messages search</name>
                        <script>-- disabled: this doesn't work great with admin / suicided persons

ndb.temp_name_list = {}</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>1</conditonLineDelta>
                        <mStayOpen>999</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>   ID   Sender</string>
                            <string>---------------</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>2</integer>
                            <integer>2</integer>
                        </regexCodePropertyList>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Message from a person</name>
                            <script>ndb.temp_name_list[#ndb.temp_name_list + 1] = {
  name = matches[2]
}</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string> *\d+   ([A-Z][a-z]+)</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Messages search (end)</name>
                            <script>setTriggerStayOpen(&quot;Messages search&quot;, 0)

db:merge_unique(ndb.db.people, ndb.temp_name_list)

ndb.temp_name_list = nil

raiseEvent(&quot;NameDB got new data&quot;)</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>return isPrompt()</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>4</integer>
                            </regexCodePropertyList>
                        </Trigger>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Who here</name>
                        <script>local names = multimatches[3][1]:split(&quot;, &quot;)

local data = {}
for i = 1, #names do
  data[#data+1] = {name = names[i]}
end

db:merge_unique(ndb.db.people, data)

mm.prompttrigger(&quot;new data, don't erase line&quot;, function() raiseEvent(&quot;NameDB got new data&quot;) end)</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>1</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>You see the following people here:</string>
                            <string>1</string>
                            <string>.+</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                            <integer>5</integer>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Ascendant raised</name>
                        <script>local temp_name_list = temp_name_list or {}

temp_name_list[#temp_name_list + 1] = {
  name = multimatches[2][2]
}

db:merge_unique(ndb.db.people, temp_name_list)

mm.prompttrigger(&quot;new data, don't erase line&quot;, function() raiseEvent(&quot;NameDB got new data&quot;) end)</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>A new Ascendant rises!</string>
                            <string>^A new Ascendant rises! By decree of .+? and with full support of .+?, let it be known that .+? has this day imbued (\w+) with the energies of .+?, raising a Vernal Ascendant!$</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>2</integer>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                </TriggerGroup>
                <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Honors on a person</name>
                    <script></script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList/>
                    <regexCodePropertyList/>
                    <Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Honors</name>
                        <script>if ndb.honorsid then killTimer(ndb.honorsid) end

temp_name_list = {}
temp_name_list[1] = {
  name = ndb.honorsname, demigod = 0,
  guildenemy = 0, orgenemy = 0, immortal = 0,
  gender = line:find(&quot;%f[%a][mM]ale%f[%A]&quot;) and 'male' or 'female',
  title = line:match(&quot;(.-) %(&quot;)
}

local brackets = line:match(&quot;%((.-)%)&quot;)
if brackets:find(&quot;%f[%a]God%f[%A]&quot;) or brackets:find(&quot;%f[%a]Goddess%f[%A]&quot;) or brackets:find(&quot;%f[%a]Ephemeral%f[%A]&quot;) then
  temp_name_list[1].immortal = 1
  temp_name_list[1].gender = &quot;&quot;
elseif brackets:find(&quot;Demigod&quot;,1,true) then
  temp_name_list[1].demigod = 1
end


ndb.honors_line_count = 0

local startline = getLineNumber()
for i = 1, 10 do -- word wrapping can mess it up, go so back a fair bit in case of small screen

  -- work backwards until the line with the name is located
  if string.find(getCurrentLine(), &quot;%f[%a]&quot;..ndb.honorsname..&quot;%f[%A]&quot;) or getCurrentLine():starts(&quot;A small shrubbery&quot;) then
    -- pick up the race as it is listed
    local race = getCurrentLine():match(&quot;%(male (.-)%)&quot;) or getCurrentLine():match(&quot;%(female (.-)%)&quot;) or &quot;&quot;

    if ndb.isvalidrace(race) then
      temp_name_list[1].race = race:lower()
    end

    break
  end
  if ndb.gaghonours then deleteLine() end
  moveCursor(0, startline-i)
end
moveCursorEnd()</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>100</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>return line:find(&quot;%f[%a]&quot;..ndb.honorsname..&quot;%f[%A]&quot;) and line:find(&quot;(&quot;, 1, true) and line:find(&quot;)&quot;, 1, true)</string>
                            <string>A small shrubbery (</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>4</integer>
                            <integer>2</integer>
                        </regexCodePropertyList>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>XP rank</name>
                            <script>temp_name_list[1].xp_rank = tonumber(matches[2])

-- 200 is a safe amount to set it at, as the number will vary
if tonumber(matches[2]) &lt; 200 then temp_name_list[1].demigod = 1 end</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>^(?:She|He) is ranked (\d+)\w+ in Lusternia\.</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Unranked</name>
                            <script>temp_name_list[1].xp_rank = -2</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>He is unranked in Lusternia.</string>
                                <string>She is unranked in Lusternia.</string>
                                <string>He has cut his thread from the Tapestry of the Fates.</string>
                                <string>She has cut her thread from the Tapestry of the Fates.</string>
                                <string>He is frozen in time and space.</string>
                                <string>She is frozen in time and space.</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>3</integer>
                                <integer>3</integer>
                                <integer>3</integer>
                                <integer>3</integer>
                                <integer>3</integer>
                                <integer>3</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Org &amp; rank</name>
                            <script>local org = ndb.findfromtable(matches[3], ndb.valid.orgs)

if org then
  temp_name_list[1].org_rank = ndb.getorgrank(matches[2])
  temp_name_list[1].org = org
end</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>^(?:He|She) is a (.+?) in the (.+)?\.</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Might</name>
                            <script>temp_name_list[1].might = tonumber(matches[2])

-- toads are an It</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>87</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>^(?:She|He|It) is considered to be approximately (\d+)% of your might\.$</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Equal might</name>
                            <script>temp_name_list[1].might = 100</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>He is considered to be approximately equal to your might.</string>
                                <string>She is considered to be approximately equal to your might.</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>3</integer>
                                <integer>3</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Avatar</name>
                            <script>temp_name_list[1].order = matches[2]</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>(?:He|She) is an Avatar of (\w+),</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>City/Commune enemy</name>
                            <script>temp_name_list[1].orgenemy = 1</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>(?:He|She) is an enemy of your (?:commune|city)\.$</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>1</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Guildenemy</name>
                            <script>temp_name_list[1].guildenemy = 1</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>He is an enemy of your guild.</string>
                                <string>She is an enemy of your guild.</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>3</integer>
                                <integer>3</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Stop getting (honors)</name>
                            <script>setTriggerStayOpen(&quot;Honors&quot;, 0)
disableTrigger(&quot;Honors&quot;)

-- didn't get honors - person has laurels?
if ndb.honors_line_count == 2 then
  -- don't erase namedb data with other false we might've collected then
  temp_name_list[1] = {laurels = 1, immortal = temp_name_list[1].immortal, gender = temp_name_list[1].gender, name = temp_name_list[1].name, demigod = temp_name_list[1].demigod}
end

db:merge_unique(ndb.db.people, temp_name_list)

local gaghonours = ndb.gaghonours
ndb.honorsid, ndb.gaghonours = nil, nil

raiseEvent(&quot;NameDB finished honors&quot;, temp_name_list[1].name, (gaghonours and &quot;quiet&quot; or &quot;manual&quot;))

temp_name_list = nil
ndb.honors_line_count = nil</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>0</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>return isPrompt()</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>4</integer>
                            </regexCodePropertyList>
                        </Trigger>
                        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                            <name>Any line</name>
                            <script>if ndb.gaghonours then deleteLine() end

-- this can go off on the prompt when we're done with everything
if ndb.honors_line_count then
  ndb.honors_line_count = ndb.honors_line_count + 1
end</script>
                            <triggerType>0</triggerType>
                            <conditonLineDelta>99</conditonLineDelta>
                            <mStayOpen>0</mStayOpen>
                            <mCommand></mCommand>
                            <packageName></packageName>
                            <mFgColor>#ff0000</mFgColor>
                            <mBgColor>#ffff00</mBgColor>
                            <mSoundFile></mSoundFile>
                            <colorTriggerFgColor>#000000</colorTriggerFgColor>
                            <colorTriggerBgColor>#000000</colorTriggerBgColor>
                            <regexCodeList>
                                <string>return true</string>
                            </regexCodeList>
                            <regexCodePropertyList>
                                <integer>4</integer>
                            </regexCodePropertyList>
                        </Trigger>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>No Honours</name>
                        <script>if ndb.honorsid then killTimer(ndb.honorsid) ndb.honorsid = nil else return end

disableTrigger(&quot;Honors&quot;)

if ndb.gaghonours then mm.deleteLineP() end

echo(&quot;\n&quot;)
mm.echof(ndb.honorsname .. &quot; doesn't exist anymore, deleted them.&quot;)

db:delete(ndb.db.people, db:eq(ndb.db.people.name, ndb.honorsname))

raiseEvent(&quot;NameDB name deleted&quot;, ndb.honorsname)

-- maintain a list of deleted people for getinfo to ignore, as the website still lists them: and thus getinfo re-adds them.
ndb.deletednames = ndb.deletednames or {}
ndb.deletednames[ndb.honorsname] = true

local gaghonours = ndb.gaghonours
ndb.gaghonours = nil

raiseEvent(&quot;NameDB finished honors&quot;, &quot;&quot;, (gaghonours and &quot;quiet&quot; or &quot;manual&quot;))</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>There is no such person, I'm afraid.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Immortal</name>
                        <script>if ndb.honorsid then killTimer(ndb.honorsid) ndb.honorsid = nil end

disableTrigger(&quot;Honors&quot;)

if ndb.gaghonours then mm.deleteLineP() end

local temp_name_list = {}
temp_name_list[1] = {name = ndb.honorsname, immortal = 1}
db:merge_unique(ndb.db.people, temp_name_list)

local gaghonours = ndb.gaghonours
ndb.gaghonours = nil

raiseEvent(&quot;NameDB finished honors&quot;, ndb.honorsname, (gaghonours and &quot;quiet&quot; or &quot;manual&quot;))</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>She was born before time was counted.</string>
                            <string>He was born before time was counted.</string>
                            <string>Administrators are here to adjudicate issues and are responsible for addressing game mechanics. Administrators do not have a roleplaying function.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                            <integer>3</integer>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                </TriggerGroup>
            </TriggerGroup>
        </TriggerGroup>
    </TriggerPackage>
    <TimerPackage/>
    <AliasPackage>
        <AliasGroup isActive="yes" isFolder="yes">
            <name>NameDB</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <regex></regex>
            <Alias isActive="yes" isFolder="no">
                <name>Who is</name>
                <script>ndb.showwhois(matches[2]:lower())</script>
                <command></command>
                <packageName></packageName>
                <regex>^whois (\w+)$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>Honors a person</name>
                <script>ndb.honors(matches[2], &quot;manual&quot;)</script>
                <command></command>
                <packageName></packageName>
                <regex>^honou?rs? (\w+)$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(ndb set person category value) Adjust person data</name>
                <script>local name = matches[2]:title()
local category = matches[3]
local towhat = tonumber(matches[4]) or matches[4]

local temp_name_list = {}

if category == &quot;city&quot; or category == &quot;commune&quot; then category = &quot;org&quot; end

if category == &quot;org&quot; then
  towhat = towhat:title()
  towhat = (towhat == &quot;New celest&quot;) and &quot;New Celest&quot; or towhat

  if not ndb.isvalidorg(towhat) then
    mm.echof(&quot;%s isn't a known org, sorry.\n  Available ones are: %s&quot;, towhat, mm.concatand(ndb.valid.orgs))
    return
  end

elseif category == &quot;class&quot; then
  towhat = towhat:lower()
  if not ndb.isvalidclass(towhat) then
    mm.echof(&quot;%s isn't a known class, sorry.\n  Available ones are: %s&quot;, towhat, mm.concatand(ndb.valid.classes))
    return
  end

elseif category == &quot;race&quot; then
  towhat = towhat:lower()
  if not ndb.isvalidrace(towhat) then
    mm.echof(&quot;%s isn't a known race, sorry.\n  Available ones are: %s&quot;, towhat, mm.concatand(ndb.valid.races))
    return
  end

end

if category == &quot;guild&quot; or category == &quot;order&quot; then towhat = towhat:title() end
if category == &quot;notes&quot; then towhat = towhat:gsub([[\n]], &quot;\n&quot;) end

if category == &quot;orgenemy&quot; or category == &quot;guildenemy&quot; or category == &quot;orderenemy&quot; or category == &quot;immortal&quot; or category == &quot;demigod&quot; or category == &quot;laurels&quot; then
  towhat = mm.toboolean(towhat) and 1 or 0
end

temp_name_list[#temp_name_list + 1] = {
  name = name,
  [category] = towhat
}

db:merge_unique(ndb.db.people, temp_name_list)

ndb.showwhois(name)

-- re-honors person if necessary
if category == &quot;xp_rank&quot; or category == &quot;might&quot; then
  raiseEvent&quot;NameDB got new data&quot;
end

raiseEvent(&quot;NameDB set name changed&quot;, name)

-- regenerate order mmconfigs
if category == &quot;order&quot; then ndb.setuporders() end</script>
                <command></command>
                <packageName></packageName>
                <regex>^ndb set (\w+) ([a-z_]+) (.+)$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(iff person status)</name>
                <script>ndb.setiff(matches[2], matches[3])

ndb.showwhois(matches[2])</script>
                <command></command>
                <packageName></packageName>
                <regex>^iff (\w+) (\w+)$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>qw/qw2</name>
                <script>ndb.checkqw(matches[2])</script>
                <command></command>
                <packageName></packageName>
                <regex>^qw(2)?$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(qw update) Re-check people on qw list</name>
                <script>ndb.checkqw(nil, &quot;update&quot;)</script>
                <command></command>
                <packageName></packageName>
                <regex>^qw update$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(qwc) Organize by org members</name>
                <script>ndb.checkqw(nil, &quot;organize orgs&quot;)</script>
                <command></command>
                <packageName></packageName>
                <regex>^qwc$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(ppof) Report visible citizens of an org</name>
                <script>ndb.checkqw(nil, &quot;report members of &quot;..matches[2])</script>
                <command></command>
                <packageName></packageName>
                <regex>^ppof (\w+)</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(npp) Toggle name highlighting</name>
                <script>mm.config.set(&quot;ndbpaused&quot;, matches[2], true)</script>
                <command></command>
                <packageName></packageName>
                <regex>^npp(?: (\w+))?$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(ndb stats) See DB stats</name>
                <script>mm.echof(&quot;Compiling database stats...&quot;)
mm.showprompt()

local function makestats()
  local alldata = db:fetch(ndb.db.people)

  if not alldata or not next(alldata) then mm.echof(&quot;Your NameDB is empty! Check 'qw', 'citizens' to start filling it up...&quot;) return end

  local totalcount = #alldata

  local orgs = {}
  for i = 1, #alldata do
    local p = alldata[i]
    if not p.org or p.org == '' then p.org = &quot;none&quot; end
    orgs[p.org] = orgs[p.org] or {}
    orgs[p.org][#orgs[p.org]+1] = p.name
  end
  local orgssorted = {}; for org in pairs(orgs) do orgssorted[#orgssorted+1] = {org, #orgs[org]} end
  table.sort(orgssorted, function(a, b)
    return a[2] &gt; b[2]
  end)

  echo'\n'
  mm.echof(&quot;People in the DB: %s&quot;, totalcount)
  mm.echof(&quot;Org stats:&quot;)
  for i = 1, #orgssorted do
    cecho(string.format(&quot;  %-15s - %d citizens.\n&quot;, orgssorted[i][1], orgssorted[i][2]))
  end

  mm.showprompt()
end

tempTimer(0, makestats)</script>
                <command></command>
                <packageName></packageName>
                <regex>^ndb stats$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(ndb cancel) Cancel honors'ing people</name>
                <script>ndb.cancelhonors()</script>
                <command></command>
                <packageName></packageName>
                <regex>^ndb cancel$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(ndb honorsnew) Honors backlog of new people</name>
                <script>ndb.manualcheck = true
ndb.updatebyhonors()</script>
                <command></command>
                <packageName></packageName>
                <regex>^ndb honorsnew$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(ndb export) export DB</name>
                <script>-- keep the location used between exports
local oldlocation = false
if ndb.exportdata and ndb.exportdata.location then oldlocation = ndb.exportdata.location end

ndb.exportdata = {
  fields = {},
  people = {all = true},
  location = oldlocation
}

-- setup defaults
for key, _ in pairs(ndb.schema.people) do
  if key:sub(1,1) ~= &quot;_&quot; then ndb.exportdata.fields[key] = true end
end
ndb.exportdata.fields.notes = false

ndb.exportmenu()</script>
                <command></command>
                <packageName></packageName>
                <regex>^ndb export$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(ndb import) import DB</name>
                <script>-- keep the location used between imports
local oldlocation = false
if ndb.importdata and ndb.importdata.location then oldlocation = ndb.importdata.location end

ndb.importdata = {
  location = oldlocation,
  data = false,
  fields = {},
}

if ndb.importdata.location then ndb.getimportfields() end
ndb.importmenu()</script>
                <command></command>
                <packageName></packageName>
                <regex>^ndb import$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(ndb delete all) Wipe the database clean</name>
                <script>if not ndb.deleteall then
  mm.echof(&quot;Are you really sure you want to wipe the database completely clean? Nothing will be saved, and this is irreversible. If yes, do this again.&quot;)
  mm.showprompt()
  ndb.deleteall = true
  return
end

ndb.deleteall = nil
db:delete(ndb.db.people, true)

-- clear highlights
ndb.loadhighlights()

mm.echof(&quot;Database completely wiped.&quot;)
mm.showprompt()</script>
                <command></command>
                <packageName></packageName>
                <regex>^ndb delete all$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(ndb update all) Re-check every person in the database</name>
                <script>local alldata = db:fetch(ndb.db.people)

if #alldata &gt;= 100 and not ndb.updateall then
  mm.echof(&quot;Are you really sure you want to re-check everybody in the database? You've got %d names - this'll take a while.&quot;, #alldata)
  mm.showprompt()
  ndb.updateall = true
  return
end

ndb.updateall = nil
ndb.fixed_set(ndb.db.people.might, -1)

mm.echof(&quot;Re-checking all %d known people in NameDB.&quot;, #alldata)
raiseEvent(&quot;NameDB got new data&quot;)</script>
                <command></command>
                <packageName></packageName>
                <regex>^ndb update all$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(ndb delete person) Delete one individual entry</name>
                <script>if matches[2] == &quot;all&quot; then return end -- handled by another alias

local name = matches[2]:title()

local exists = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))

if not (exists and next(exists)) then mm.echof(&quot;%s doesn't exist in the database already.&quot;, name) mm.showprompt() return end

db:delete(ndb.db.people, db:eq(ndb.db.people.name, name))

raiseEvent(&quot;NameDB name deleted&quot;, name)

mm.echof(&quot;Deleted %s's entry from NameDB.&quot;, name)
mm.showprompt()</script>
                <command></command>
                <packageName></packageName>
                <regex>^ndb delete (\w+)$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>(mmshow highlightignore) See people on highlightignore</name>
                <script>local l = (next(mm.me.highlightignore) and mm.oneconcat(mm.me.highlightignore) or &quot;(none - use mmconfig highlightignore &lt;person&gt; to add)&quot;)
mm.echof(&quot;People on the highlightignore list: %s&quot;, l)
mm.showprompt()</script>
                <command></command>
                <packageName></packageName>
                <regex>^mmshow highlightignore$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>Enemies lists</name>
                <script>if ndb.checkingenemies then killTimer(ndb.checkingenemies[1]) end

ndb.checkingenemies = {
  tempTimer(10+getNetworkLatency(), [[
    ndb.checkingenemies = nil
    disableTrigger&quot;Org/Guild/Order enemies&quot;
  ]]),
  option = (matches[3] and matches[3]:trim() or nil),
  command = matches[2]
}

enableTrigger&quot;Org/Guild/Order enemies&quot;
send(matches[2]..&quot; enemies&quot;, false)</script>
                <command></command>
                <packageName></packageName>
                <regex>^(city|commune|guild|order) enemies( add)?$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>ndb alias cheatsheet</name>
                <script>-- load help data in
if not ndb.help then
if not lfs.attributes(getMudletHomeDir()..&quot;/&quot;..class..&quot; m&amp;m&quot;) then
  mm.echof(&quot;You don't seem to have installed m&amp;m as a package in the name of \&quot;&quot;..class..&quot; m&amp;m\&quot; - I can't find the ndb help file!&quot;)
  return
end

local f, msg = io.open(getMudletHomeDir()..&quot;/&quot;..class..&quot; m&amp;m/ndb-help.lua&quot;)
if not f then
  mm.echof(&quot;Didn't find the ndb-help.lua file in '&quot;..getMudletHomeDir()..&quot;/&quot;..class..&quot; m&amp;m/ndb-help.lua&quot;..&quot;' - I can't show you the aliases!&quot;)
  return
end

local s = f:read(&quot;*a&quot;)

   local data = loadstring(&quot;return &quot;..s)()
	if not data then
		mm.echof(&quot;Couldn't load data from the ndb-help.lua file :/ maybe it is messed up.&quot;)
		return
	end

	ndb.help = data
end

local function gettooltip(entry)
  return table.concat(entry.definition, &quot;\n&quot;)
end

local function getdesc(entry)
  return table.concat(entry.definition, &quot;\n&quot;)
end

local function showshort()
	mm.echof(&quot;ndb alias cheatsheet:&quot;)

	for id, entry in pairs(ndb.help) do
		fg(&quot;DarkSlateGrey&quot;) echo&quot;  * &quot; setFgColor(unpack(mm.getDefaultColorNums)) echoLink(entry.term, 'ndb.showhelp('..id..')', gettooltip(entry), true) echo&quot;\n&quot;
	end
end

local function showlong()
	mm.echof(&quot;ndb alias cheatsheet (extended):&quot;)

	for id, entry in pairs(ndb.help) do
		fg(&quot;DarkSlateGrey&quot;) echo&quot;  * &quot; setFgColor(unpack(mm.getDefaultColorNums)) echoLink(entry.term, 'ndb.showhelp('..id..')', gettooltip(entry), true) echo&quot;\n&quot;
		echo&quot;      &quot; echo(getdesc(entry)) echo&quot;\n&quot;  echo&quot;\n&quot;
	end
end

if matches[2] then showlong() else showshort() end
mm.showprompt() echo'\n'</script>
                <command></command>
                <packageName></packageName>
                <regex>^ndb( long)?$</regex>
            </Alias>
        </AliasGroup>
    </AliasPackage>
    <ActionPackage/>
    <ScriptPackage>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>NameDB</name>
            <packageName></packageName>
            <script>ndb = ndb or {}</script>
            <eventHandlerList/>
            <Script isActive="yes" isFolder="no">
                <name>ndb.init</name>
                <packageName></packageName>
                <script>ndb.schema = {
  people = {
    name        = &quot;&quot;,
    title       = &quot;&quot;,
    gender      = &quot;&quot;,
    class       = &quot;&quot;,
    org        = &quot;&quot;,
    org_rank   = 0,
    guild       = &quot;&quot;,
    might       = -1, -- 0 is a possible might, -1 unknown
    importance  = 0,
    xp_rank     = -1, -- -1 default, -2 unranked
    immortal    = 0,
    iff         = -1, -- -1 autodetected, 1 enemy, 2 ally
    orgenemy   = 0, -- 0 is not enemy, 1 is enemy
    orderenemy  = 0, -- 0 is not enemy, 1 is enemy
    guildenemy  = 0, -- 0 is not enemy, 1 is enemy
    order       = &quot;&quot;,
    notes       = &quot;&quot;,
    demigod     = 0,
    race        = &quot;&quot;,
    laurels     = 0, -- laurels: remember this, so we don't honors them all the time

    _unique     = {&quot;name&quot;},
    _violations = &quot;REPLACE&quot;
  },
}

function ndb.init()
  ndb.db = db:create(&quot;NameDB&quot;, ndb.schema)
  -- necessary on Windows, because its IO tends to... slow down with time.
  -- http://www.sqlite.org/pragma.html#pragma_synchronous
  db.__conn[&quot;namedb&quot;]:execute(&quot;pragma synchronous = OFF&quot;)

  -- shuffle Celestians into New Celest as they should be
  local c = #(db:fetch(ndb.db.people, db:eq(ndb.db.people.org, &quot;Celest&quot;)))
  if c ~= 0 then
    -- wait for ndb.fixed_set to be loaded
    tempTimer(0, [[ndb.fixed_set(ndb.db.people.org, &quot;New Celest&quot;, db:eq(ndb.db.people.org, &quot;Celest&quot;)); mm.echof(&quot;Migrated ]]..c..[[ Celestians into New Celest as they should be.&quot;)]])
  end
end

ndb.init()</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>ndb.valid</name>
                <packageName></packageName>
                <script>ndb.valid = ndb.valid or {}

ndb.valid.orgs = {
  &quot;Magnagora&quot;, &quot;New Celest&quot;, &quot;Hallifax&quot;, &quot;Gaudiguch&quot;, &quot;Glomdoring&quot;, &quot;Serenwilde&quot;
}
ndb.valid.classes = {
  &quot;aeromancer&quot;, &quot;aquamancer&quot;, &quot;blacktalon&quot;, &quot;cacophonist&quot;, &quot;cantor&quot;, &quot;celestine&quot;, &quot;ebonguard&quot;, &quot;geomancer&quot;, &quot;harbinger&quot;, &quot;hartstone&quot;, &quot;illuminati&quot;, &quot;researcher&quot;, &quot;minstrel&quot;, &quot;moondancer&quot;, &quot;nekotai&quot;, &quot;nihilist&quot;, &quot;ninjakari&quot;, &quot;paladin&quot;, &quot;pyromancer&quot;, &quot;sentinel&quot;, &quot;serenguard&quot;, &quot;shadowdancer&quot;, &quot;shofangi&quot;, &quot;spiritsinger&quot;, &quot;symphonist&quot;, &quot;tahtetso&quot;, &quot;templar&quot;, &quot;ur'guard&quot;,
}
ndb.valid.guilds = {
  &quot;Aeromancers&quot;, &quot;Aquamancers&quot;, &quot;Blacktalon&quot;, &quot;Cacophony&quot;, &quot;Cantors&quot;, &quot;Celestines&quot;, &quot;Ebonguard&quot;, &quot;Geomancers&quot;, &quot;Harbingers&quot;, &quot;Hartstone&quot;, &quot;Illuminati&quot;, &quot;Institute&quot;, &quot;Minstrels&quot;, &quot;Moondancers&quot;, &quot;Nekotai&quot;, &quot;Nihilists&quot;, &quot;Ninjakari&quot;, &quot;Paladins&quot;, &quot;Pyromancers&quot;, &quot;Sentinels&quot;, &quot;Serenguard&quot;, &quot;Shadowdancers&quot;, &quot;Shofangi&quot;, &quot;Spiritsingers&quot;, &quot;Symphonium&quot;, &quot;Tahtetso&quot;, &quot;Templars&quot;, &quot;Ur'Guard&quot;,
}
ndb.valid.races = {
  &quot;human&quot;, &quot;dwarf&quot;, &quot;elfen&quot;, &quot;dracnari&quot;, &quot;faeling&quot;, &quot;furrikin&quot;, &quot;krokani&quot;, &quot;aslaran&quot;, &quot;loboshigaru&quot;, &quot;mugwump&quot;, &quot;merian&quot;, &quot;orclach&quot;, &quot;igasho&quot;, &quot;tae'dae&quot;, &quot;taurian&quot;, &quot;trill&quot;, &quot;viscanti&quot;, &quot;lucidian&quot;, &quot;kephera&quot;, &quot;illithoid&quot;,
}

ndb.valid.guildtoclass = {
  [&quot;Ur'Guard&quot;]  = &quot;ur'guard&quot;,
  Aeromancers   = &quot;aeromancer&quot;,
  Aquamancers   = &quot;aquamancer&quot;,
  Blacktalon    = &quot;blacktalon&quot;,
  Cacophony     = &quot;cacophonist&quot;,
  Cantors       = &quot;cantor&quot;,
  Celestines    = &quot;celestine&quot;,
  Ebonguard     = &quot;ebonguard&quot;,
  Geomancers    = &quot;geomancer&quot;,
  Harbingers    = &quot;harbinger&quot;,
  Hartstone     = &quot;hartstone&quot;,
  Illuminati    = &quot;illuminati&quot;,
  Institute     = &quot;researcher&quot;,
  Minstrels     = &quot;minstrel&quot;,
  Moondancers   = &quot;moondancer&quot;,
  Nekotai       = &quot;nekotai&quot;,
  Nihilists     = &quot;nihilist&quot;,
  Ninjakari     = &quot;ninjakari&quot;,
  Paladins      = &quot;paladin&quot;,
  Pyromancers   = &quot;pyromancer&quot;,
  Sentinels     = &quot;sentinel&quot;,
  Serenguard    = &quot;serenguard&quot;,
  Shadowdancers = &quot;shadowdancer&quot;,
  Shofangi      = &quot;shofangi&quot;,
  Spiritsingers = &quot;spiritsinger&quot;,
  Symphonium    = &quot;symphonist&quot;,
  Tahtetso      = &quot;tahtetso&quot;,
  Templars      = &quot;templar&quot;,
}

ndb.valid.orgranks = {
  [1] = {&quot;serf&quot;, &quot;peasant&quot;, &quot;ward&quot;}, 
  [2] = {&quot;laborer&quot;, &quot;goodman&quot;, &quot;goodwoman&quot;, &quot;woman&quot;, &quot;gardener&quot;}, 
  [3] = {&quot;supervisor&quot;, &quot;nobleman&quot;, &quot;noblewoman&quot;, &quot;woodsman&quot;, &quot;woodswoman&quot;,}, 
  [4] = {&quot;master&quot;, &quot;mistress&quot;, &quot;lord&quot;, &quot;lady&quot;, &quot;forest custodian&quot;, }, 
  [5] = {&quot;viscount&quot;, &quot;viscountess&quot;, &quot;count&quot;, &quot;countess&quot;, &quot;high forester&quot;,},
  [6] = {&quot;marquis&quot;, &quot;marquessa&quot;, &quot;earl&quot;, &quot;earless&quot;, &quot;shadow warden&quot;, &quot;dark seneschal&quot;, &quot;forest warden&quot;, &quot;guardian of the seren&quot;, &quot;seneschal&quot;},
}

function ndb.isvalidorg(which)
  which = which:title()
  return table.contains(ndb.valid.orgs, which) and true or false
end

function ndb.isvalidclass(which)
  which = which:lower()
  return table.contains(ndb.valid.classes, which) and true or false
end

function ndb.isvalidrace(which)
  which = which:lower()
  return table.contains(ndb.valid.races, which) and true or false
end</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>ndb.support</name>
                <packageName></packageName>
                <script>-- ndb.support

function ndb.tablemerge(t, other)
   for other_key, other_items in pairs(other) do
      if not t[other_key] then
         t[other_key] = other_items
      else
         local group = t[other_key]
         for item_key, item_value in pairs(other_items) do
            group[item_key] = item_value
         end
      end
   end
   return t
end

-- given a string and a table of possible answers, returns the first possible answer, if any
function ndb.findfromtable(input, data)
  local sfind = string.find

  for i = 1, #data do
    if sfind(input, data[i], 1, true) then return data[i] end
  end
end

function ndb.honors(name, type)
  if ndb.honorsid then mm.echof(&quot;ndb.honors() for %s called, when already honours'ing %s - not going to do this.&quot;, name:title(), ndb.honorsname:title()) return end
  name = name:lower():title()

  enableTrigger(&quot;Honors&quot;)

  if ndb.honorsid then killTimer(ndb.honorsid) end
  ndb.honorsid = tempTimer(2+getNetworkLatency(), function()
    disableTrigger(&quot;Honors&quot;)
    mm.echof(&quot;Honors on %s didn't happen - re-checking...&quot;, name)
    ndb.honorsid, ndb.gaghonours = nil, nil
    ndb.honors(name, type)
  end)

  ndb.honorsname = name
  send(&quot;honors &quot; .. name, false) -- needs to full so it sees the clan listing

  if type == &quot;quiet&quot; then ndb.gaghonours = true end

  -- check up on their guild/org status while also HONORSing
  ndb.download2(name, false)
end

function ndb.cancelhonors(quietly)
  ndb.manualcheck = nil

  if (ndb.honorslist and next(ndb.honorslist)) or ndb.honorsid then
    ndb.honorslist = {}
    if ndb.honorsid then killTimer(ndb.honorsid) disableTrigger(&quot;Honors&quot;) end; ndb.honorsid = nil
    if not quietly then mm.echof(&quot;Cancelled honors-checking people.&quot;) end
  else
    if not quietly then mm.echof(&quot;Not checking anyone atm already.&quot;) end
  end
  if not quietly then mm.showprompt() end

  ndb.hidehonorswindow()
end

function ndb.getorgrank(rankname)
  rankname = rankname:lower()
  local contains = table.contains

  for rank, titles in ipairs(ndb.valid.orgranks) do
    if contains(titles, rankname) then return rank end
  end
end

-- -&gt; string
-- get own org name, with a special exception for translating Celest into New Celest
function ndb.getmyorg()
  local org = gmcp.Char.Status.city:match(&quot;^(%w+)&quot;)
  org = (org == &quot;Celest&quot; and &quot;New Celest&quot; or org)
  return org
end

-- update all info that we should be able to glean from honors.
-- might: if it's at -1, then it's default known
-- rank: -1 default unknown, -2 unranked
function ndb.updatebyhonors()
  local data = db:fetch(ndb.db.people, db:AND(db:not_eq(ndb.db.people.immortal, 1), db:not_eq(ndb.db.people.laurels, 1), db:OR(db:eq(ndb.db.people.xp_rank, -1), db:eq(ndb.db.people.might, -1))))

  ndb.honorslist = (function ()
    local t = {}
    for i,j in ipairs(data) do
      -- sanity check for weird names
      if j.name:find(&quot;^%u%l+$&quot;) then t[j.name] = true
      else db:delete(ndb.db.people, db:eq(ndb.db.people.name, j.name)) end
    end return t end)()

    if mm.conf.paused or not next(ndb.honorslist) then return end

    if not mm.conf.autohonors and not ndb.manualcheck then
      if table.size(ndb.honorslist) &gt; 1 then
        echo'\n'
        if table.size(ndb.honorslist) &lt;= 10 then
          mm.echofn(&quot;Got new names (%s), use '&quot;, mm.oneconcat(ndb.honorslist))
          setFgColor(unpack(mm.getDefaultColorNums))
          setUnderline(true)
          echoLink(&quot;ndb honorsnew&quot;, 'ndb.manualcheck = true; ndb.updatebyhonors()', 'Click to do ndb honorsnew', true)
          setUnderline(false)
          echo(&quot;' to check them.\n&quot;)
        else
          mm.echofn(&quot;Got %d new names, use '&quot;, table.size(ndb.honorslist))
          setFgColor(unpack(mm.getDefaultColorNums))
          setUnderline(true)
          echoLink(&quot;ndb honorsnew&quot;, 'ndb.manualcheck = true; ndb.updatebyhonors()', 'Click to do ndb honorsnew', true)
          setUnderline(false)
          echo(&quot;' to check them.\n&quot;)
        end
      end

      return
    end

    if table.size(ndb.honorslist) &lt;= 10 then
      echo'\n' mm.echof(&quot;Have new names (%s) - going to check them.&quot;, mm.oneconcat(ndb.honorslist))
    else
      echo'\n' mm.echof(&quot;Have %s new names - going to check them.&quot;, table.size(ndb.honorslist))
    end

  if not ndb.honorsid then ndb_honors_next() end
end

function ndb.doexport()
  if not ndb.exportdata.location then return nil, &quot;no export location&quot; end

  local alldata = db:fetch(ndb.db.people)

  if not alldata or not next(alldata) then mm.echof(&quot;Your NameDB is empty! Check 'qw', 'citizens' to start filling it up. There's nothing to export otherwise...&quot;) return end

  for i = 1, #alldata do
    local p = alldata[i]

    -- see if we need to prune the result first
    if not ndb.exportdata.people.all then
      alldata[i] = nil

    else
      -- prune fields we don't need
      for key,value in pairs(ndb.exportdata.fields) do
        if key ~= &quot;name&quot; and not value then p[key] = nil end
      end

      -- prune internal fields starting with underscores
      local removekeys = {}
      for key, _ in pairs(p) do
        if key:sub(1,1) == '_' then
          removekeys[#removekeys+1] = key
        end
      end

      for i = 1, #removekeys do p[removekeys[i]] = nil end
    end
  end

  -- build the final table that we'll table.save()
  local exportable = {
    meta = { author = mm.me.name, date = os.date(&quot;%A %d, %b '%y&quot;), fields =  ndb.exportdata.fields },
    data = alldata
  }

  local location = string.format(&quot;%s/%s's namedb, %s&quot;, ndb.exportdata.location, mm.me.name, os.date(&quot;%A %d, %b '%y&quot;))
  table.save(location, exportable)
  echo'\n' mm.echof(&quot;Data exported okay, it's in %s.&quot;, location)
end

-- reads selected files for fields available within it to import
function ndb.getimportfields()

  if not ndb.importdata.location or not io.exists(ndb.importdata.location) then ndb.importdata.location = nil; return end

  ndb.importdata.data = {}
  table.load(ndb.importdata.location, ndb.importdata.data)
  if not ndb.importdata.data then mm.echof(&quot;Couldn't read the file - maybe it's corrupted? Try another.&quot;) return end

  for k,v in pairs(ndb.importdata.data.meta.fields) do if ndb.schema.people[k] then ndb.importdata.fields[k] = true end end
end

function ndb.doimport()
  if not ndb.importdata.data then return nil, &quot;no data loaded in ndb.importdata.data&quot; end

  -- copy data over for importing with only the fields we need
  local temp_name_list = {}

  -- data.data as the original data is stored in .data of the new field that's imported.
  for i = 1, #ndb.importdata.data.data do
    local p = ndb.importdata.data.data[i]

    temp_name_list[#temp_name_list + 1] = {
      name = p.name,
    }

    for k,v in pairs(p) do
      if ndb.importdata.fields[k] then
        temp_name_list[#temp_name_list][k] = v
      end
    end
  end

  db:merge_unique(ndb.db.people, temp_name_list)
  mm.echof(&quot;Imported %d name%s okay.&quot;, #temp_name_list, (#temp_name_list == 1 and '' or 's'))

  raiseEvent(&quot;NameDB got new data&quot;)
  ndb.importdata.data = nil
end
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>ndb_honors_next</name>
                    <packageName></packageName>
                    <script>function ndb_honors_next(event, name, type)
	if mm.conf.paused or not ndb.honorslist then return end

	local name = next(ndb.honorslist)
	if not name then
		if type ~= &quot;manual&quot; then echo'\n' mm.echof(&quot;Done checking all new names.&quot;) mm.showprompt() end
		ndb.manualcheck = nil
		ndb.hidehonorswindow()
		return
	end

	if not mm.conf.autohonors and not ndb.manualcheck then return end

	ndb.honors(name, &quot;quiet&quot;)
	ndb.honorslist[name] = nil
    local left = table.size(ndb.honorslist)
	--tempTimer(0, function() mm.echof(&quot;Checking %s, %s name%s left to check...\n&quot;, name, left, (left == 1 and '' or 's')) end)
	ndb.showhonorswindow(string.format(&quot;Checking %s, %s name%s left to check...\n&quot;, name, left, (left == 1 and '' or 's')))
end</script>
                    <eventHandlerList>
                        <string>NameDB finished honors</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>ndb.updatebyhonors</name>
                    <packageName></packageName>
                    <script>-- this just registers the handler, the script is supposed to be blank</script>
                    <eventHandlerList>
                        <string>NameDB got new data</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>ndb.ui</name>
                    <packageName></packageName>
                    <script>function ndb.showhonorswindow(text)
  ndb.autohonorslabel = ndb.autohonorslabel or Geyser.Label:new({
    name = &quot;ndb.autohonorslabel&quot;,
    x = &quot;-340px&quot;, y = &quot;-35px&quot;,
    width = &quot;320px&quot;, height = &quot;25px&quot;,
  })

  ndb.autohonorslabel:setStyleSheet([[
    margin: 0px;
    padding: 2px;

    background: rgba(0, 0, 51, 75%);
    border: none;
    border-radius: 4px;

    qproperty-alignment: 'AlignLeft | AlignVCenter';
    qproperty-wordWrap: true;
    font-family: 'Ubuntu','Calibri',serif;
  ]])

  ndb.autohonorslabel:show()
  ndb.autohonorslabel:echo([[&lt;p style=&quot;color: grey; font-size: 15px;&quot;&gt;]]..text..[[&lt;/p&gt;]])
end

function ndb.hidehonorswindow()
  if ndb.autohonorslabel then ndb.autohonorslabel:hide() end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>ndb.configs</name>
                    <packageName></packageName>
                    <script>function ndb.setuporders()
  local r = db:fetch_sql(ndb.db.people, [[SELECT DISTINCT &quot;order&quot; FROM 'people';]])
  if not r then return end

  table.sort(r, function(a,b) return a.order &lt; b.order end)

  for i = 1, #r do
    if r[i].order ~= &quot;&quot; then
      local order = r[i].order

      mm.config.setoption(&quot;highlight&quot;..order:lower(), {
        type = &quot;boolean&quot;,
        onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s highlight %s's Order members.&quot;, mm.getDefaultColor(), order) end,
        ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s highlight %s's Order members.&quot;, mm.getDefaultColor(), order) end,
      })
      mm.config.setoption(&quot;bold&quot;..order:lower(), {
        type = &quot;boolean&quot;,
        onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s bold %s's Order members.&quot;, mm.getDefaultColor(), order) end,
        ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s bold %s's Order members.&quot;, mm.getDefaultColor(), order) end,
      })
      mm.config.setoption(&quot;underline&quot;..order:lower(), {
        type = &quot;boolean&quot;,
        onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s underline %s's Order members.&quot;, mm.getDefaultColor(), order) end,
        ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s underline %s's Order members.&quot;, mm.getDefaultColor(), order) end,
      })
      mm.config.setoption(&quot;italicize&quot;..order:lower(), {
        type = &quot;boolean&quot;,
        onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s italicize %s's Order members.&quot;, mm.getDefaultColor(), order) end,
        ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s italicize %s's Order members.&quot;, mm.getDefaultColor(), order) end,
      })

      mm.config.setoption(order:lower()..&quot;color&quot;, {
        type = &quot;string&quot;,
        check = function (what)
          if color_table[what] then return true end
        end,
        onset = function ()
          ndb.loadhighlights()
          local r,g,b = unpack(color_table[mm.conf[order:lower()..&quot;color&quot;]])
          mm.echof(&quot;Highlighting %s Order members in &lt;%s,%s,%s&gt;%s%s now.&quot;, order, r,g,b, mm.conf[order:lower()..&quot;color&quot;], mm.getDefaultColor())
        end,
      })
    end
  end
end

function ndb.configs()
  if mm.conf.autohonors == nil then mm.conf.autohonors = true end
  if mm.conf.ndbpause == nil then mm.conf.ndbpause = false end

  mm.config.setoption(&quot;autohonors&quot;, {
    type = &quot;boolean&quot;,
    vconfig2string = true,
    onenabled = function () mm.echof(&quot;&lt;0,250,0&gt;Will%s automatically, and quietly, honors new people we come across.&quot;, mm.getDefaultColor()) ndb.updatebyhonors() end,
    ondisabled = function () mm.echof(&quot;&lt;250,0,0&gt;Won't%s automatically honors new people. Use 'ndb honorsnew' to clear the new names backlog manually.&quot;, mm.getDefaultColor()) ndb.cancelhonors(true) end,
    onshow = function (defaultcolour)
      fg(&quot;gold&quot;)
      echoLink(&quot;NameDB:&quot;, &quot;&quot;, &quot;m&amp;m NameDB&quot;, true)
      fg(defaultcolour) echo(&quot; &quot;)
      fg(&quot;a_cyan&quot;) echoLink(mm.conf.autohonors and &quot;Auto-checking&quot; or &quot;Not auto-checking&quot;, &quot;mm.config.set('autohonors', &quot;..(mm.conf.autohonors and &quot;false&quot; or &quot;true&quot;)..&quot;, true)&quot;, &quot;Click to &quot;..(mm.conf.autohonors and &quot;disable&quot; or &quot;enable&quot;)..&quot; automatic honors checks on new people that we see&quot;, true)
      fg(defaultcolour)
      echo(&quot; new people, highlighting names is &quot;)
      fg(defaultcolour)
      fg(&quot;a_cyan&quot;) echoLink(not mm.conf.ndbpaused and &quot;on&quot; or &quot;off&quot;, &quot;mm.config.set('ndbpaused', &quot;..(mm.conf.ndbpaused and &quot;false&quot; or &quot;true&quot;)..&quot;, true)&quot;, &quot;Click to &quot;..(mm.conf.ndbpaused and &quot;start&quot; or &quot;stop&quot;)..&quot; highlighting names&quot;, true)
      fg(defaultcolour)
      echo(&quot;.\n&quot;)
    end
  })

  mm.config.setoption(&quot;ndbpaused&quot;, {
    type = &quot;boolean&quot;,
    onenabled = function () ndb.loadhighlights() mm.echof(&quot;Name highlighting &lt;250,0,0&gt;stopped%s.&quot;, mm.getDefaultColor()) end,
    ondisabled = function () ndb.loadhighlights() mm.echof(&quot;Name highlighting &lt;0,250,0&gt;resumed%s.&quot;, mm.getDefaultColor()) end
  })

  mm.conf.autoclassset = mm.conf.autoclassset or 10
  mm.config.setoption(&quot;autoclassset&quot;, {
    type = &quot;number&quot;,
    vconfig2string = true,
    onshow = function (defaultcolour)
      fg(&quot;gold&quot;)
      echoLink(&quot;NameDB:&quot;, &quot;&quot;, &quot;m&amp;m NameDB&quot;, true)
      fg(defaultcolour) echo(&quot; Capture a persons class after &quot;)
      fg(&quot;a_cyan&quot;) echoLink(tostring(mm.conf.autoclassset), &quot;printCmdLine('mmconfig autoclassset ')&quot;, &quot;Click to set the amount of consecutive attacks a person must do from a particular class before it's recorded in NameDB. This is for anti-illusion purposes, so illusions can't easily make NameDB mess with their known class&quot;, true)
      fg(defaultcolour)
      echo(&quot; consecutive attacks.\n&quot;)
    end
  })

  mm.config.setoption(&quot;politics&quot;, {
    type = &quot;custom&quot;,
    onmenu = function () ndb.showpolitics(true) end,
  })

  local function setupwatchfor()
    mm.config.setoption(&quot;highlightwatchfor&quot;, {
      type = &quot;boolean&quot;,
      onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s highlight names on the watchfor list.&quot;, mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s highlight names on the watchfor list.&quot;, mm.getDefaultColor()) end,
    })
    mm.config.setoption(&quot;boldwatchfor&quot;, {
      type = &quot;boolean&quot;,
      onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s bold names on the watchfor list.&quot;, mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s bold names on the watchfor list.&quot;, mm.getDefaultColor()) end,
    })
    mm.config.setoption(&quot;underlinewatchfor&quot;, {
      type = &quot;boolean&quot;,
      onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s underline names on the watchfor list.&quot;, mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s underline names on the watchfor list.&quot;, mm.getDefaultColor()) end,
    })
    mm.config.setoption(&quot;italicizewatchfor&quot;, {
      type = &quot;boolean&quot;,
      onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s italicize names on the watchfor list.&quot;, mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s italicize names on the watchfor list.&quot;, mm.getDefaultColor()) end,
    })

    mm.config.setoption(&quot;watchforcolor&quot;, {
      type = &quot;string&quot;,
      check = function (what)
        if color_table[what] then return true end
      end,
      onset = function ()
        ndb.loadhighlights()
        local r,g,b = unpack(color_table[mm.conf.watchforcolor])
        mm.echof(&quot;Highlighting watchfor names in &lt;%s,%s,%s&gt;%s%s now.&quot;, r,g,b, mm.conf.watchforcolor, mm.getDefaultColor())
      end,
    })
  end

  local function setuporgs()
    for _, org in ipairs(ndb.valid.orgs) do
      mm.config.setoption(&quot;highlight&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;), {
        type = &quot;boolean&quot;,
        onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s highlight citizens of %s.&quot;, mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s highlight citizens of %s.&quot;, mm.getDefaultColor(), org) end,
      })
      mm.config.setoption(&quot;bold&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;), {
        type = &quot;boolean&quot;,
        onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s bold the names of %s citizens.&quot;, mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s bold the names of %s citizens.&quot;, mm.getDefaultColor(), org) end,
      })
      mm.config.setoption(&quot;underline&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;), {
        type = &quot;boolean&quot;,
        onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s underline the names of %s citizens.&quot;, mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s underline the names of %s citizens.&quot;, mm.getDefaultColor(), org) end,
      })
      mm.config.setoption(&quot;italicize&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;), {
        type = &quot;boolean&quot;,
        onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s italicize the names of %s citizens.&quot;, mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s italicize the names of %s citizens.&quot;, mm.getDefaultColor(), org) end,
      })

      mm.config.setoption(org:lower():gsub(&quot; &quot;, &quot;&quot;)..&quot;color&quot;, {
        type = &quot;string&quot;,
        check = function (what)
          if color_table[what] then return true end
        end,
        onset = function ()
          ndb.loadhighlights()
          local r,g,b = unpack(color_table[mm.conf[org:lower():gsub(&quot; &quot;, &quot;&quot;)..&quot;color&quot;]])
          mm.echof(&quot;Highlighting %s citizens in &lt;%s,%s,%s&gt;%s%s now.&quot;, org, r,g,b, mm.conf[org:lower():gsub(&quot; &quot;, &quot;&quot;)..&quot;color&quot;], mm.getDefaultColor())
        end,
      })
    end
  end

  local function setuprogues()
    mm.config.setoption(&quot;highlightrogues&quot;, {
      type = &quot;boolean&quot;,
      onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s highlight rogues.&quot;, mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s highlight rogues.&quot;, mm.getDefaultColor()) end,
    })
    mm.config.setoption(&quot;boldrogues&quot;, {
      type = &quot;boolean&quot;,
      onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s bold the names of rogues.&quot;, mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s bold the names of rogues.&quot;, mm.getDefaultColor()) end,
    })
    mm.config.setoption(&quot;underlinerogues&quot;, {
      type = &quot;boolean&quot;,
      onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s underline the names of rogues.&quot;, mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s underline the names of rogues.&quot;, mm.getDefaultColor()) end,
    })
    mm.config.setoption(&quot;italicizerogues&quot;, {
      type = &quot;boolean&quot;,
      onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s italicize the names of rogues.&quot;, mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s italicize the names of rogues.&quot;, mm.getDefaultColor()) end,
    })

    mm.config.setoption(&quot;roguescolor&quot;, {
      type = &quot;string&quot;,
      check = function (what)
        if color_table[what] then return true end
      end,
      onset = function ()
        ndb.loadhighlights()
        local r,g,b = unpack(color_table[mm.conf[&quot;roguescolor&quot;]])
        mm.echof(&quot;Highlighting rogues in &lt;%s,%s,%s&gt;%s%s now.&quot;, r,g,b, mm.conf[&quot;roguescolor&quot;], mm.getDefaultColor())
      end,
    })
  end

  local function setupenemies()
    for _, org in ipairs({&quot;org&quot;, &quot;guild&quot;, &quot;order&quot;}) do
      mm.config.setoption(&quot;highlight&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;), {
        type = &quot;boolean&quot;,
        onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s highlight enemies of your of %s.&quot;, mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s highlight enemies of your of %s.&quot;, mm.getDefaultColor(), org) end,
      })
      mm.config.setoption(&quot;bold&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;), {
        type = &quot;boolean&quot;,
        onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s bold the names of your %s enemies.&quot;, mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s bold the names of your %s enemies.&quot;, mm.getDefaultColor(), org) end,
      })
      mm.config.setoption(&quot;underline&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;), {
        type = &quot;boolean&quot;,
        onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s underline the names of your %s enemies.&quot;, mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s underline the names of your %s enemies.&quot;, mm.getDefaultColor(), org) end,
      })
      mm.config.setoption(&quot;italicize&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;), {
        type = &quot;boolean&quot;,
        onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s italicize the names of your %s enemies.&quot;, mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s italicize the names of your %s enemies.&quot;, mm.getDefaultColor(), org) end,
      })

      mm.config.setoption(org:lower():gsub(&quot; &quot;, &quot;&quot;)..&quot;color&quot;, {
        type = &quot;string&quot;,
        check = function (what)
          if color_table[what] then return true end
        end,
        onset = function ()
          ndb.loadhighlights()
          local r,g,b = unpack(color_table[mm.conf[org:lower():gsub(&quot; &quot;, &quot;&quot;)..&quot;color&quot;]])
          mm.echof(&quot;Highlighting your %s enemies in &lt;%s,%s,%s&gt;%s%s now.&quot;, org, r,g,b, mm.conf[org:lower():gsub(&quot; &quot;, &quot;&quot;)..&quot;color&quot;], mm.getDefaultColor())
        end,
      })
    end
  end

  local function setupdivines()
    mm.config.setoption(&quot;highlightdivine&quot;, {
      type = &quot;boolean&quot;,
      onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s highlight Divines.&quot;, mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s highlight Divines.&quot;, mm.getDefaultColor()) end,
    })
    mm.config.setoption(&quot;bolddivine&quot;, {
      type = &quot;boolean&quot;,
      onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s bold Divines.&quot;, mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s bold Divines.&quot;, mm.getDefaultColor()) end,
    })
    mm.config.setoption(&quot;underlinedivine&quot;, {
      type = &quot;boolean&quot;,
      onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s underline Divines.&quot;, mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s underline Divines.&quot;, mm.getDefaultColor()) end,
    })
    mm.config.setoption(&quot;italicizedivine&quot;, {
      type = &quot;boolean&quot;,
      onenabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;0,250,0&gt;Will%s italicize Divines.&quot;, mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof(&quot;&lt;250,0,0&gt;Won't%s italicize Divines.&quot;, mm.getDefaultColor()) end,
    })

    mm.config.setoption(&quot;divinecolor&quot;, {
      type = &quot;string&quot;,
      check = function (what)
        if color_table[what] then return true end
      end,
      onset = function ()
        ndb.loadhighlights()
        local r,g,b = unpack(color_table[mm.conf.divinecolor])
        mm.echof(&quot;Highlighting Divines in &lt;%s,%s,%s&gt;%s%s now.&quot;, r,g,b, mm.conf.divinecolor, mm.getDefaultColor())
      end,
    })
  end

  local function addhighlightignore()
    mm.me.highlightignore = mm.me.highlightignore or {}

    mm.config.setoption(&quot;highlightignore&quot;, {
      type = &quot;string&quot;,
      check = function(what)
        if what:find(&quot;^%w+$&quot;) then return true end
      end,
      onset = function ()
        local name = string.title(mm.conf.highlightignore)
        -- we want nil, not false so 'or' doesn't help
        if mm.me.highlightignore[name] then mm.me.highlightignore[name] = nil else mm.me.highlightignore[name] = true end

        if mm.me.highlightignore[name] then
          mm.echof(&quot;Added &lt;0,255,0&gt;%s%s to the highlightignore list - so we won't highlight them.&quot;, name, mm.getDefaultColor())
        else
          mm.echof(&quot;Removed %s from the highlightignore list.&quot;, name)
        end
        raiseEvent(&quot;NameDB highlightignore name changed&quot;, name)
      end
    })
  end

  setuporgs()
  setuprogues()
  setupwatchfor()
  setupenemies()
  setupdivines()
  ndb.setuporders()
  addhighlightignore()
end

-- improve: add background colors
function ndb.showpolitics(noprompt)
  local echo, setFgColor, setUnderline, setFgColor, echoLink = echo, setFgColor, setUnderline, setFgColor, echoLink
  mm.echof(&quot;Adjust org stances and setup highlights (currently highlighting %s names):&quot;, table.size(ndb.highlightIDs))
  mm.echofn(&quot;(click on underlined to change, &quot;)
    setFgColor(unpack(mm.getDefaultColorNums))
    setUnderline(true) echoLink(&quot;view color list&quot;, &quot;showColors()&quot;, &quot;Click here to view the list of possible colors you can choose&quot;, true) setUnderline(false)
    echo(&quot;):\n\n&quot;)

  local function showorgs()
    mm.echof(&quot;Org politics:&quot;)

    -- orgs
    for _, org in ipairs(ndb.valid.orgs) do
      local status = ndb.conf.orgpolitics[org]
      local extraspaces = 0
      setFgColor(unpack(mm.getDefaultColorNums))
      echo(&quot;  &quot;)
      echo(string.format(&quot;%-10s is &quot;, org))

      local nextstatus
      if status == &quot;ally&quot; then fg(&quot;a_green&quot;); nextstatus = &quot;enemy&quot;; status = &quot;an ally&quot;; extraspaces = 7
      elseif status == &quot;enemy&quot; then fg(&quot;a_red&quot;); nextstatus = &quot;neutral&quot;; status = &quot;an enemy&quot;; extraspaces = 8
      else fg(&quot;a_darkwhite&quot;); nextstatus = &quot;ally&quot;; extraspaces = 7 end

      if mm.conf.org ~= org then
        setUnderline(true) echoLink(tostring(status), &quot;ndb.conf.orgpolitics['&quot;..org..&quot;'] = '&quot;..nextstatus..&quot;'; ndb.showpolitics()&quot;, 'Click to set '..org..&quot;s status to &quot;..nextstatus, true) setUnderline(false)
      else
        setFgColor(unpack(mm.getDefaultColorNums)) echo(&quot;your home&quot;); extraspaces = 9
      end

      setFgColor(unpack(mm.getDefaultColorNums))
      echo(&quot;,&quot;)
      echo((&quot; &quot;):rep(10-extraspaces))

      setUnderline(true)
      echoLink(mm.conf[&quot;highlight&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] and &quot;highlighting&quot; or &quot;not highlighting&quot;,
        'mm.config.set(&quot;highlight'..org:lower():gsub(&quot; &quot;, &quot;&quot;)..'&quot;, '..(mm.conf[&quot;highlight&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
        'Click to '..(mm.conf[&quot;highlight&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] and &quot;stop&quot; or &quot;start&quot;).. ' highlighting citizens of '..org,
      true)
      setUnderline(false)

      if not mm.conf[&quot;highlight&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] then
        echo(&quot; its citizens in any color,  &quot;)
      else
        echo((&quot; &quot;):rep(4))
        echo(&quot; its citizens in &quot;)
        setUnderline(true)
        setFgColor(unpack(color_table[mm.conf[org:lower():gsub(&quot; &quot;, &quot;&quot;)..&quot;color&quot;] or &quot;a_darkwhite&quot;]))
        echoLink(mm.conf[org:lower():gsub(&quot; &quot;, &quot;&quot;)..&quot;color&quot;] or &quot;a_darkwhite&quot;,
          &quot;printCmdLine'mmconfig &quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)..&quot;color '&quot;,
          'Click to set the color of '..org..' citizens',
        true)
        setUnderline(false)
        setFgColor(unpack(mm.getDefaultColorNums))
        echo(&quot;,&quot;)
        echo((&quot; &quot;):rep(11-#(mm.conf[org:lower():gsub(&quot; &quot;, &quot;&quot;)..&quot;color&quot;] or &quot;a_darkwhite&quot;)))
      end

      echo(&quot;(&quot;)

      setUnderline(true)
      echoLink(mm.conf[&quot;bold&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] and &quot;bold&quot; or &quot;no bld&quot;,
        'mm.config.set(&quot;bold'..org:lower():gsub(&quot; &quot;, &quot;&quot;)..'&quot;, '..(mm.conf[&quot;bold&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
        'Click to '..(mm.conf[&quot;bold&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] and &quot;stop&quot; or &quot;start&quot;).. ' bolding citizens of '..org,
      true)
      setUnderline(false)
      echo(&quot;, &quot;)

      setUnderline(true)
      echoLink(mm.conf[&quot;underline&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] and &quot;undl&quot; or &quot;no undl&quot;,
        'mm.config.set(&quot;underline'..org:lower():gsub(&quot; &quot;, &quot;&quot;)..'&quot;, '..(mm.conf[&quot;underline&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
        'Click to '..(mm.conf[&quot;underline&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] and &quot;stop&quot; or &quot;start&quot;).. ' underlining citizens of '..org,
      true)
      setUnderline(false)
      echo(&quot;, &quot;)

      setUnderline(true)
      echoLink(mm.conf[&quot;italicize&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] and &quot;ital&quot; or &quot;no ital&quot;,
        'mm.config.set(&quot;italicize'..org:lower():gsub(&quot; &quot;, &quot;&quot;)..'&quot;, '..(mm.conf[&quot;italicize&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
        'Click to '..(mm.conf[&quot;italicize&quot;..org:lower():gsub(&quot; &quot;, &quot;&quot;)] and &quot;stop&quot; or &quot;start&quot;).. ' italicizing citizens of '..org,
      true)
      setUnderline(false)

      echo(&quot;)&quot;)

      echo('\n')
    end

    -- rogues
    setFgColor(unpack(mm.getDefaultColorNums))
    echo(&quot;  Rogues are neutral,      &quot;)

    setUnderline(true)
    echoLink(mm.conf[&quot;highlightrogues&quot;] and &quot;highlighting&quot; or &quot;not highlighting&quot;,
      'mm.config.set(&quot;highlightrogues&quot;, '..(mm.conf[&quot;highlightrogues&quot;] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
      'Click to '..(mm.conf[&quot;highlightrogues&quot;] and &quot;stop&quot; or &quot;start&quot;).. ' highlighting rogues',
    true)
    setUnderline(false)

    if not mm.conf[&quot;highlightrogues&quot;] then
      echo(&quot; them in any color,&quot;)
      echo((&quot; &quot;):rep(10))
    else
      echo((&quot; &quot;):rep(4))
      echo(&quot; them in &quot;)
      setUnderline(true)
      setFgColor(unpack(color_table[mm.conf[&quot;roguescolor&quot;] or &quot;a_darkwhite&quot;]))
      echoLink(mm.conf[&quot;roguescolor&quot;] or &quot;a_darkwhite&quot;,
        &quot;printCmdLine'mmconfig rogues&quot;..&quot;color '&quot;,
        'Click to set the color of rogues',
      true)
      setUnderline(false)
      setFgColor(unpack(mm.getDefaultColorNums))
      echo(&quot;, &quot;)
      echo((&quot; &quot;):rep(18-#(mm.conf[&quot;roguescolor&quot;] or &quot;a_darkwhite&quot;)))
    end

    echo(&quot;(&quot;)

    setUnderline(true)
    echoLink(mm.conf[&quot;boldrogues&quot;] and &quot;bold&quot; or &quot;no bld&quot;,
      'mm.config.set(&quot;boldrogues&quot;, '..(mm.conf[&quot;boldrogues&quot;] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
      'Click to '..(mm.conf[&quot;boldrogues&quot;] and &quot;stop&quot; or &quot;start&quot;).. ' bolding rogues',
    true)
    setUnderline(false)
    echo(&quot;, &quot;)

    setUnderline(true)
    echoLink(mm.conf[&quot;underlinerogues&quot;] and &quot;undl&quot; or &quot;no undl&quot;,
      'mm.config.set(&quot;underlinerogues&quot;, '..(mm.conf[&quot;underlinerogues&quot;] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
      'Click to '..(mm.conf[&quot;underlinerogues&quot;] and &quot;stop&quot; or &quot;start&quot;).. ' underlining rogues',
    true)
    setUnderline(false)
    echo(&quot;, &quot;)

    setUnderline(true)
    echoLink(mm.conf[&quot;italicizerogues&quot;] and &quot;ital&quot; or &quot;no ital&quot;,
      'mm.config.set(&quot;italicizerogues&quot;, '..(mm.conf[&quot;italicizerogues&quot;] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
      'Click to '..(mm.conf[&quot;italicizerogues&quot;] and &quot;stop&quot; or &quot;start&quot;).. ' italicizing rogues',
    true)
    setUnderline(false)

    echo(&quot;)&quot;)

    echo('\n')
  end

  local function showwatchfor()
    mm.echof(&quot;Watchfor list:&quot;)
    setFgColor(unpack(mm.getDefaultColorNums))
    echo(&quot;  &quot;)
    setUnderline(true)
    echoLink(mm.conf[&quot;highlightwatchfor&quot;] and &quot;Highlighting&quot; or &quot;Not highlighting&quot;,
      'mm.config.set(&quot;highlightwatchfor&quot;, '..(mm.conf[&quot;highlightwatchfor&quot;] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
      'Click to '..(mm.conf[&quot;highlightwatchfor&quot;] and &quot;stop&quot; or &quot;start&quot;).. ' highlighting names on the watchfor list',
    true)
    setUnderline(false)

    if not mm.conf[&quot;highlightwatchfor&quot;] then
      echo(&quot; names on the watchfor list. &quot;)
      echo((&quot; &quot;):rep(25))
    else
      echo(&quot; names on the watchfor list in &quot;)
      setUnderline(true)
      setFgColor(unpack(color_table[mm.conf[&quot;watchforcolor&quot;] or &quot;a_darkwhite&quot;]))
      echoLink(mm.conf[&quot;watchforcolor&quot;] or &quot;a_darkwhite&quot;,
        &quot;printCmdLine'mmconfig watchfor&quot;..&quot;color '&quot;,
        'Click to set the color of names on the watchfor list',
      true)
      setUnderline(false)
      setFgColor(unpack(mm.getDefaultColorNums))
      echo(&quot;, &quot;)
      echo((&quot; &quot;):rep(25-#(mm.conf[&quot;watchforcolor&quot;] or &quot;a_darkwhite&quot;)))
    end

    echo(&quot;(&quot;)

    setUnderline(true)
    echoLink(mm.conf[&quot;boldwatchfor&quot;] and &quot;bold&quot; or &quot;no bld&quot;,
      'mm.config.set(&quot;boldwatchfor&quot;, '..(mm.conf[&quot;boldwatchfor&quot;] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
      'Click to '..(mm.conf[&quot;boldwatchfor&quot;] and &quot;stop&quot; or &quot;start&quot;).. ' bolding names on watchfor list',
    true)
    setUnderline(false)
    echo(&quot;, &quot;)

    setUnderline(true)
    echoLink(mm.conf[&quot;underlinewatchfor&quot;] and &quot;undl&quot; or &quot;no undl&quot;,
      'mm.config.set(&quot;underlinewatchfor&quot;, '..(mm.conf[&quot;underlinewatchfor&quot;] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
      'Click to '..(mm.conf[&quot;underlinewatchfor&quot;] and &quot;stop&quot; or &quot;start&quot;).. ' underlining names on watchfor list',
    true)
    setUnderline(false)
    echo(&quot;, &quot;)

    setUnderline(true)
    echoLink(mm.conf[&quot;italicizewatchfor&quot;] and &quot;ital&quot; or &quot;no ital&quot;,
      'mm.config.set(&quot;italicizewatchfor&quot;, '..(mm.conf[&quot;italicizewatchfor&quot;] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
      'Click to '..(mm.conf[&quot;italicizewatchfor&quot;] and &quot;stop&quot; or &quot;start&quot;).. ' italicizing names on watchfor list',
    true)
    setUnderline(false)

    echo(&quot;)&quot;)
    echo(&quot;\n&quot;)
  end

  local function showdivines()
    mm.echof(&quot;Divine list:&quot;)
    setFgColor(unpack(mm.getDefaultColorNums))
    echo(&quot;  &quot;)
    setUnderline(true)
    echoLink(mm.conf[&quot;highlightdivine&quot;] and &quot;Highlighting&quot; or &quot;Not highlighting&quot;,
      'mm.config.set(&quot;highlightdivine&quot;, '..(mm.conf[&quot;highlightdivine&quot;] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
      'Click to '..(mm.conf[&quot;highlightdivine&quot;] and &quot;stop&quot; or &quot;start&quot;).. ' highlighting Divines',
    true)
    setUnderline(false)

    if not mm.conf[&quot;highlightdivine&quot;] then
      echo(&quot; Divines. &quot;)
      echo((&quot; &quot;):rep(44))
    else
      echo(&quot; Divines in &quot;)
      setUnderline(true)
      setFgColor(unpack(color_table[mm.conf[&quot;divinecolor&quot;] or &quot;a_darkwhite&quot;]))
      echoLink(mm.conf[&quot;divinecolor&quot;] or &quot;a_darkwhite&quot;,
        &quot;printCmdLine'mmconfig divine&quot;..&quot;color '&quot;,
        'Click to set the color of Divine names',
      true)
      setUnderline(false)
      setFgColor(unpack(mm.getDefaultColorNums))
      echo(&quot;, &quot;)
      echo((&quot; &quot;):rep(44-#(mm.conf[&quot;divinecolor&quot;] or &quot;a_darkwhite&quot;)))
    end

    echo(&quot;(&quot;)

    setUnderline(true)
    echoLink(mm.conf[&quot;bolddivine&quot;] and &quot;bold&quot; or &quot;no bld&quot;,
      'mm.config.set(&quot;bolddivine&quot;, '..(mm.conf[&quot;bolddivine&quot;] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
      'Click to '..(mm.conf[&quot;bolddivine&quot;] and &quot;stop&quot; or &quot;start&quot;).. ' bolding Divines',
    true)
    setUnderline(false)
    echo(&quot;, &quot;)

    setUnderline(true)
    echoLink(mm.conf[&quot;underlinedivine&quot;] and &quot;undl&quot; or &quot;no undl&quot;,
      'mm.config.set(&quot;underlinedivine&quot;, '..(mm.conf[&quot;underlinedivine&quot;] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
      'Click to '..(mm.conf[&quot;underlinedivine&quot;] and &quot;stop&quot; or &quot;start&quot;).. ' underlining Divines',
    true)
    setUnderline(false)
    echo(&quot;, &quot;)

    setUnderline(true)
    echoLink(mm.conf[&quot;italicizedivine&quot;] and &quot;ital&quot; or &quot;no ital&quot;,
      'mm.config.set(&quot;italicizedivine&quot;, '..(mm.conf[&quot;italicizedivine&quot;] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
      'Click to '..(mm.conf[&quot;italicizedivine&quot;] and &quot;stop&quot; or &quot;start&quot;).. ' italicizing Divines',
    true)
    setUnderline(false)

    echo(&quot;)&quot;)
    echo(&quot;\n&quot;)
  end

  local function showenemies()
    mm.echof(&quot;Guild, Org and Order enemies:&quot;)

    for _, org in ipairs({&quot;guild&quot;, &quot;org&quot;, &quot;order&quot;}) do
      setFgColor(unpack(mm.getDefaultColorNums))
      echo(&quot;  &quot;)
      setUnderline(true)
      echoLink(mm.conf[&quot;highlight&quot;..org] and &quot;Highlighting&quot; or &quot;Not highlighting&quot;,
        'mm.config.set(&quot;highlight'..org..'&quot;, '..(mm.conf[&quot;highlight&quot;..org] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
        'Click to '..(mm.conf[&quot;highlight&quot;..org] and &quot;stop&quot; or &quot;start&quot;).. ' highlighting names of your '..org..' enemies',
      true)
      setUnderline(false)

      if not mm.conf[&quot;highlight&quot;..org] then
        echo(&quot; names of your &quot;..org..&quot; enemies. &quot;)
        echo((&quot; &quot;):rep(29-#org))
      else
        echo(&quot;     names of your &quot;..org.. &quot; enemies in &quot;)
        setUnderline(true)
        setFgColor(unpack(color_table[mm.conf[org..&quot;color&quot;] or &quot;a_darkwhite&quot;]))
        echoLink(mm.conf[org..&quot;color&quot;] or &quot;a_darkwhite&quot;,
          &quot;printCmdLine'mmconfig &quot;..org..&quot;color '&quot;,
          'Click to set the color of names on '..org..' enemies list',
        true)
        setUnderline(false)
        setFgColor(unpack(mm.getDefaultColorNums))
        echo(&quot;, &quot;)
        echo((&quot; &quot;):rep(25-#org-#(mm.conf[org..&quot;color&quot;] or &quot;a_darkwhite&quot;)))
      end

      echo(&quot;(&quot;)

      setUnderline(true)
      echoLink(mm.conf[&quot;bold&quot;..org] and &quot;bold&quot; or &quot;no bld&quot;,
        'mm.config.set(&quot;bold'..org..'&quot;, '..(mm.conf[&quot;bold&quot;..org] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
        'Click to '..(mm.conf[&quot;bold&quot;..org] and &quot;stop&quot; or &quot;start&quot;).. ' bolding names of your '..org..' enemies',
      true)
      setUnderline(false)
      echo(&quot;, &quot;)

      setUnderline(true)
      echoLink(mm.conf[&quot;underline&quot;..org] and &quot;undl&quot; or &quot;no undl&quot;,
        'mm.config.set(&quot;underline'..org..'&quot;, '..(mm.conf[&quot;underline&quot;..org] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
        'Click to '..(mm.conf[&quot;underline&quot;..org] and &quot;stop&quot; or &quot;start&quot;).. ' underlining names of your '..org..' enemies',
      true)
      setUnderline(false)
      echo(&quot;, &quot;)

      setUnderline(true)
      echoLink(mm.conf[&quot;italicize&quot;..org] and &quot;ital&quot; or &quot;no ital&quot;,
        'mm.config.set(&quot;italicize'..org..'&quot;, '..(mm.conf[&quot;italicize&quot;..org] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
        'Click to '..(mm.conf[&quot;italicize&quot;..org] and &quot;stop&quot; or &quot;start&quot;).. ' italicizing names of your '..org..' enemies',
      true)
      setUnderline(false)

      echo(&quot;)&quot;)
      echo(&quot;\n&quot;)
    end
  end

  local function showordermembers()
    local r = db:fetch_sql(ndb.db.people, [[SELECT DISTINCT &quot;order&quot; FROM 'people';]])
    if not r then return end

    table.sort(r, function(a,b) return a.order &lt; b.order end)

    local shownsomething
    mm.echof(&quot;Order members:&quot;)
    for i = 1, #r do
      if r[i].order ~= &quot;&quot; then
        shownsomething = true
        local order = r[i].order

        setFgColor(unpack(mm.getDefaultColorNums))
        echo(&quot;  &quot;)
        setUnderline(true)
        echoLink(mm.conf[&quot;highlight&quot;..order:lower()] and &quot;Highlighting&quot; or &quot;Not highlighting&quot;,
          'mm.config.set(&quot;highlight'..order:lower()..'&quot;, '..(mm.conf[&quot;highlight&quot;..order:lower()] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
          'Click to '..(mm.conf[&quot;highlight&quot;..order:lower()] and &quot;stop&quot; or &quot;start&quot;).. ' highlighting names of '..order:lower()..'\'s members',
        true)
        setUnderline(false)

        if not mm.conf[&quot;highlight&quot;..order:lower()] then
          echo(&quot; names of &quot;..order..&quot;'s Order members. &quot;)
          echo((&quot; &quot;):rep(26-#order))
        else
          echo(&quot;     names of &quot;..order.. &quot;'s Order members in &quot;)
          setUnderline(true)
          setFgColor(unpack(color_table[mm.conf[order:lower()..&quot;color&quot;] or &quot;a_darkwhite&quot;]))
          echoLink(mm.conf[order:lower()..&quot;color&quot;] or &quot;a_darkwhite&quot;,
            &quot;printCmdLine'mmconfig &quot;..order:lower()..&quot;color '&quot;,
            'Click to set the color of '..order:lower()..'\'s Order members',
          true)
          setUnderline(false)
          setFgColor(unpack(mm.getDefaultColorNums))
          echo(&quot;, &quot;)
          echo((&quot; &quot;):rep(22-#order-#(mm.conf[order:lower()..&quot;color&quot;] or &quot;a_darkwhite&quot;)))
        end

        echo(&quot;(&quot;)

        setUnderline(true)
        echoLink(mm.conf[&quot;bold&quot;..order:lower()] and &quot;bold&quot; or &quot;no bld&quot;,
          'mm.config.set(&quot;bold'..order:lower()..'&quot;, '..(mm.conf[&quot;bold&quot;..order:lower()] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
          'Click to '..(mm.conf[&quot;bold&quot;..order:lower()] and &quot;stop&quot; or &quot;start&quot;).. ' bolding names '..order:lower()..'\'s Order members',
        true)
        setUnderline(false)
        echo(&quot;, &quot;)

        setUnderline(true)
        echoLink(mm.conf[&quot;underline&quot;..order:lower()] and &quot;undl&quot; or &quot;no undl&quot;,
          'mm.config.set(&quot;underline'..order:lower()..'&quot;, '..(mm.conf[&quot;underline&quot;..order:lower()] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
          'Click to '..(mm.conf[&quot;underline&quot;..order:lower()] and &quot;stop&quot; or &quot;start&quot;).. ' underlining names '..order:lower()..'\'s Order members',
        true)
        setUnderline(false)
        echo(&quot;, &quot;)

        setUnderline(true)
        echoLink(mm.conf[&quot;italicize&quot;..order:lower()] and &quot;ital&quot; or &quot;no ital&quot;,
          'mm.config.set(&quot;italicize'..order:lower()..'&quot;, '..(mm.conf[&quot;italicize&quot;..order:lower()] and &quot;false&quot; or &quot;true&quot;)..', true); ndb.showpolitics()',
          'Click to '..(mm.conf[&quot;italicize&quot;..order:lower()] and &quot;stop&quot; or &quot;start&quot;).. ' italicizing names '..order:lower()..'\'s Order members',
        true)
        setUnderline(false)

        echo(&quot;)&quot;)
        echo(&quot;\n&quot;)
      end
    end

    if not shownsomething then
      setFgColor(unpack(mm.getDefaultColorNums))
      echo(&quot;  (no members of Orders are known)&quot;)
      resetFormat()
      echo(&quot;\n&quot;)
    end
  end

  -- watchfor &gt; divine &gt; org &gt; order &gt; guild &gt; citizens
  showwatchfor()
  echo(&quot;\n&quot;)
  showdivines()
  echo(&quot;\n&quot;)
  showenemies()
  echo(&quot;\n&quot;)
  showordermembers()
  echo(&quot;\n&quot;)
  showorgs()

  if not noprompt then mm.showprompt() end
end</script>
                    <eventHandlerList>
                        <string>m&amp;m system loaded</string>
                    </eventHandlerList>
                    <Script isActive="yes" isFolder="no">
                        <name>ndb.onshow</name>
                        <packageName></packageName>
                        <script>function ndb.onshow()
    local c = table.size(mm.me.highlightignore)

    mm.echofn(&quot;# of people on the highlightignore: %d &quot;, c)

    setFgColor(unpack(mm.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;(view)&quot;, 'echo&quot;\\n&quot; expandAlias&quot;mmshow highlightignore&quot;', 'Click here open the highlightignore list menu', true)
    echo&quot;\n&quot;
end</script>
                        <eventHandlerList>
                            <string>m&amp;m onshow</string>
                        </eventHandlerList>
                    </Script>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>ndb.loadsettings</name>
                    <packageName></packageName>
                    <script>function ndb.loadsettings()
  ndb.conf = ndb.conf or {}
  ndb.conf.orgpolitics = ndb.conf.orgpolitics or {}

  local conf_path = getMudletHomeDir() .. &quot;/m&amp;m/namedb/orgpolitics&quot;

  if lfs.attributes(conf_path) then
    table.load(conf_path, ndb.conf.orgpolitics)
  end

  -- setup defaults
  if next(ndb.conf.orgpolitics) then return end

  if mm.conf.org == &quot;Magnagora&quot; then
    ndb.conf.orgpolitics = {
      Magnagora = &quot;ally&quot;, [&quot;New Celest&quot;] = &quot;enemy&quot;, Hallifax = &quot;neutral&quot;, Gaudiguch = &quot;neutral&quot;, Glomdoring = &quot;neutral&quot;, Serenwilde = &quot;neutral&quot;
    }
  elseif mm.conf.org == &quot;New Celest&quot;  then
    ndb.conf.orgpolitics = {
      Magnagora = &quot;enemy&quot;, [&quot;New Celest&quot;] = &quot;ally&quot;, Hallifax = &quot;neutral&quot;, Gaudiguch = &quot;enemy&quot;, Glomdoring = &quot;enemy&quot;, Serenwilde = &quot;neutral&quot;
    }
  elseif mm.conf.org == &quot;Hallifax&quot;  then
    ndb.conf.orgpolitics = {
      Magnagora = &quot;neutral&quot;, [&quot;New Celest&quot;] = &quot;neutral&quot;, Hallifax = &quot;ally&quot;, Gaudiguch = &quot;neutral&quot;, Glomdoring = &quot;neutral&quot;, Serenwilde = &quot;neutral&quot;
    }
  elseif mm.conf.org == &quot;Gaudiguch&quot;  then
    ndb.conf.orgpolitics = {
      Magnagora = &quot;neutral&quot;, [&quot;New Celest&quot;] = &quot;enemy&quot;, Hallifax = &quot;enemy&quot;, Gaudiguch = &quot;ally&quot;, Glomdoring = &quot;ally&quot;, Serenwilde = &quot;enemy&quot;
    }
  elseif mm.conf.org == &quot;Glomdoring&quot;  then
    ndb.conf.orgpolitics = {
      Magnagora = &quot;neutral&quot;, [&quot;New Celest&quot;] = &quot;enemy&quot;, Hallifax = &quot;neutral&quot;, Gaudiguch = &quot;ally&quot;, Glomdoring = &quot;ally&quot;, Serenwilde = &quot;enemy&quot;
    }
  elseif mm.conf.org == &quot;Serenwilde&quot;  then
    ndb.conf.orgpolitics = {
      Magnagora = &quot;neutral&quot;, [&quot;New Celest&quot;] = &quot;neutral&quot;, Hallifax = &quot;neutral&quot;, Gaudiguch = &quot;enemy&quot;, Glomdoring = &quot;enemy&quot;, Serenwilde = &quot;ally&quot;
    }
  else
    ndb.conf.orgpolitics = {
      Magnagora = &quot;neutral&quot;, [&quot;New Celest&quot;] = &quot;neutral&quot;, Hallifax = &quot;neutral&quot;, Gaudiguch = &quot;neutral&quot;, Glomdoring = &quot;neutral&quot;, Serenwilde = &quot;neutral&quot;
    }
  end
end</script>
                    <eventHandlerList>
                        <string>m&amp;m system loaded</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>ndb.fixes</name>
                    <packageName></packageName>
                    <script>function ndb.fixed_set(field, value, query)
   local db_name = field.database
   local s_name = field.sheet

   local conn = db.__conn[db_name]

   local sql_update = [[UPDATE OR %s %s SET &quot;%s&quot; = %s]]
   if query then
       sql_update = sql_update .. [[ WHERE %s]]
   end

   local sql = sql_update:format(db.__schema[db_name][s_name].options._violations, s_name, field.name, db:_coerce(field, value), query)

   db:echo_sql(sql)
   assert(conn:execute(sql))
   if db.__autocommit[db_name] then
      conn:commit()
   end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>ndb.close</name>
                    <packageName></packageName>
                    <script>function ndb.close()
  db:close()
  ioprint(&quot;ndb.close sysExitEvent&quot;)
end</script>
                    <eventHandlerList>
                        <string>sysExitEvent</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>getinfo</name>
                    <packageName></packageName>
                    <script>function ndb.download(name, reportback)
  assert(name)

  local name = name:title()
  ndb_reportnames = ndb_reportnames or {}
  ndb_reportnames[name] = reportback

  if not downloadFile then
    ((mm and mm.echof) or echo)(&quot;Your version of Mudlet doesn't support downloading files - please upgrade to 2.0+&quot;)
  else
    if not lfs.attributes(getMudletHomeDir()..&quot;/name downloads&quot;) then
		if lfs and lfs.mkdir then
         local t,s = lfs.mkdir(getMudletHomeDir()..&quot;/name downloads&quot;)
         if not t then ((mm and mm.echof) or echo)(&quot;Couldn't make the '&quot;..getMudletHomeDir()..&quot;/name downloads/' folder; &quot;..s) return end
		else
			((mm and mm.echof) or echo)(&quot;Sorry, but you need LuaFileSystem (lfs) installed, or have the '&quot;..getMudletHomeDir()..&quot;/name downloads/' folder exist.&quot;)
			return
		end
    end

    downloadFile(getMudletHomeDir()..&quot;/name downloads/&quot;..name, &quot;http://www.ironrealms.com/game/honors/Lusternia/&quot;..name);
    ((mm and mm.echof) or echo)(&quot;Retrieving information for &quot;..name..&quot;...&quot;)
  end
end

function ndb.download2(name, reportback)
  assert(name)

  local name = name:title()
  ndb_reportnames = ndb_reportnames or {}
  ndb_reportnames[name] = reportback

  if not downloadFile then
    ((mm and mm.echof) or echo)(&quot;Your version of Mudlet doesn't support downloading files - please upgrade to 2.0+&quot;)
  else
    if not lfs.attributes(getMudletHomeDir()..&quot;/name downloads&quot;) then
		if lfs and lfs.mkdir then
         local t,s = lfs.mkdir(getMudletHomeDir()..&quot;/name downloads&quot;)
         if not t then ((mm and mm.echof) or echo)(&quot;Couldn't make the '&quot;..getMudletHomeDir()..&quot;/name downloads/' folder; &quot;..s) return end
		else
			((mm and mm.echof) or echo)(&quot;Sorry, but you need LuaFileSystem (lfs) installed, or have the '&quot;..getMudletHomeDir()..&quot;/name downloads/' folder exist.&quot;)
			return
		end
    end

    downloadFile(getMudletHomeDir()..&quot;/name downloads/&quot;..name, &quot;http://api.lusternia.com/characters/&quot;..name:lower()..&quot;.json&quot;);
    if reportback then ((mm and mm.echof) or echo)(&quot;Retrieving information for &quot;..name..&quot;...&quot;) end
  end
end</script>
                    <eventHandlerList/>
                    <Script isActive="yes" isFolder="no">
                        <name>ndb.download_done</name>
                        <packageName></packageName>
                        <script>function ndb.download_done(_, filepath)
  if not filepath:find(&quot;name downloads&quot;, 1, true) then return end

  io.input(filepath)
  local s = io.read(&quot;*a&quot;)

  -- didn't get JSON data? 
  if s:find(&quot;Internal error&quot;, 1, true) or s:find(&quot;DOCTYPE html PUBLIC&quot;, 1, true) then return end

  local t = yajl.to_value(s)

  local name = t.name

  -- don't record a name that's been deleted according to honors. the name still shows up on website.
  if ndb.deletednames and ndb.deletednames[name] then return end

  local guild = t.guild:title()
  local org = t.city:title()
  local class = ndb.valid.guildtoclass[guild]
  local title = t.fullname

  if ndb_reportnames and ndb_reportnames[name] then
    local s = string.format(&quot;%s is a %s in %s&quot;, name, guild, org);
    ((mm and mm.echof) or echo)(s);
   ndb_reportnames[name] = nil
  end

  -- update data for DB, where &quot;(none)&quot; should be &quot;&quot;
  org = (org ~= &quot;(none)&quot; and org or &quot;&quot;)
  -- change Celest to New Celest, the official title
  org = (org == &quot;Celest&quot; and &quot;New Celest&quot; or org)
  guild = (guild ~= &quot;(none)&quot; and guild or &quot;&quot;)

  local temp_name_list = {{name = name, guild = guild, org = org, class = class, title = title}}

  db:merge_unique(ndb.db.people, temp_name_list)
  raiseEvent(&quot;NameDB saw list name&quot;, name)

--[[  if ndb.updatenames and next(ndb.updatenames) then
    ndb_download(table.remove(ndb.updatenames), true)
    if not next(ndb.updatenames) then
		ndb.db:_commit()
		ndb.db:_end()
	else
		mm.echof(&quot;%d left to check.&quot;, #ndb.updatenames)
	end
  end]]
  os.remove(filepath)
end</script>
                        <eventHandlerList>
                            <string>sysDownloadDone</string>
                        </eventHandlerList>
                    </Script>
                </Script>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>ndb.highlighter</name>
                <packageName></packageName>
                <script>function ndb.loadhighlights()
  ndb.highlightIDs = ndb.highlightIDs or {}
  collectgarbage(&quot;stop&quot;)

  ndb.cleartriggers()

  if mm.conf.ndbpaused then return end

  local highlight, watchfor = ndb.singlehighlight, mm.me.watchfor

  local dbnames = db:fetch(ndb.db.people)

  for i = 1, #dbnames do
    highlight(dbnames[i].name,
      dbnames[i].org or &quot;&quot;,
      dbnames[i].order or &quot;&quot;,
      dbnames[i].orgenemy or 0,
      dbnames[i].orderenemy or 0,
      dbnames[i].guildenemy or 0,
      watchfor[dbnames[i].name],
      dbnames[i].immortal or 0
    )
  end

  collectgarbage()
  raiseEvent(&quot;NameDB highlights reloaded&quot;)
end

function ndb.singlehighlight(name, org, order, orgenemy, orderenemy, guildenemy, watchfor, immortal)
  if ndb.highlightIDs and ndb.highlightIDs[name] then
    killTrigger(ndb.highlightIDs[name])
  end

  if name == mm.me.name or mm.me.highlightignore[name] or mm.conf.ndbpaused then return end

  local color, bold, underline, italicize
  local conf = mm.conf

  -- order of priority: watchfor &gt; divine &gt; org &gt; order &gt; guild &gt; citizens.

  org = org:lower():gsub(&quot; &quot;, &quot;&quot;)
  if order == &quot;&quot; then order = false else order = order:lower() end

  -- color first
  if conf.highlightwatchfor and watchfor then
    color     = conf.watchforcolor or &quot;a_darkwhite&quot;

  elseif conf.highlightdivine and immortal == 1 then
    color     = conf.divinecolor or &quot;a_darkwhite&quot;

  elseif conf.highlightorg and orgenemy == 1 then
    color     = conf.orgcolor or &quot;a_darkwhite&quot;

  elseif conf.highlightorder and orderenemy == 1 then
    color     = conf.ordercolor or &quot;a_darkwhite&quot;

  elseif conf.highlightguild and guildenemy == 1 then
    color     = conf.guildcolor or &quot;a_darkwhite&quot;

  elseif order and conf[&quot;highlight&quot;..order] then
    color     = conf[order..&quot;color&quot;] or &quot;a_darkwhite&quot;

  elseif org == &quot;&quot; and conf.highlightrogues then
    color     = conf.roguescolor or &quot;a_darkwhite&quot;

  elseif org and conf[&quot;highlight&quot;..org] then
    color     = conf[org..&quot;color&quot;] or &quot;a_darkwhite&quot;
  end

  -- rest of things
  bold      = (conf.boldwatchfor and watchfor)            or
                (conf.boldorg and orgenemy == 1)          or
                (conf.boldorder and orderenemy == 1)      or
                (conf.boldguild and guildenemy == 1)      or
                (conf.bolddivine and immortal == 1)       or
                (order and conf[&quot;bold&quot;..order])           or
                (org == &quot;&quot; and conf.boldrogues)           or
                (org and conf[&quot;bold&quot;..org])

  underline = (conf.underlinewatchfor and watchfor)       or
                (conf.underlineorg and orgenemy == 1)     or
                (conf.underlineorder and orderenemy == 1) or
                (conf.underlineguild and guildenemy == 1) or
                (conf.underlinedivine and immortal == 1)  or
                (order and conf[&quot;underline&quot;..order])      or
                (org == &quot;&quot; and conf.underlinerogues)      or
                (org and conf[&quot;underline&quot;..org])

  italicize = (conf.italicizewatchfor and watchfor)       or
                (conf.italicizeorg and orgenemy == 1)     or
                (conf.italicizeorder and orderenemy == 1) or
                (conf.italicizeguild and guildenemy == 1) or
                (conf.italicizedivine and immortal == 1)  or
                (order and conf[&quot;italicize&quot;..order])      or
                (org == &quot;&quot; and conf.italicizerogues)      or
                (org and conf[&quot;italicize&quot;..org])

  if not (color or bold or underline or italicize) then return end

  ndb.highlightIDs = ndb.highlightIDs or {}
  ndb.highlightIDs[name] = tempTrigger(name, ([[ndb.highlight(&quot;%s&quot;, %s, %s, %s, %s)]]):format(name,
    (color     and '&quot;'..color..'&quot;' or &quot;false&quot;),
    (bold      and &quot;true&quot; or &quot;false&quot;),
    (underline and &quot;true&quot; or &quot;false&quot;),
    (italicize and &quot;true&quot; or &quot;false&quot;)
  ))
end

function ndb.cleartriggers()
  if not ndb.highlightIDs or not next(ndb.highlightIDs) then return end

  local killTrigger = killTrigger
  for k,v in pairs(ndb.highlightIDs) do
    killTrigger(v)
  end

  ndb.highlightIDs = {}
end

function ndb.highlight(who, color, bold, underline, italicize)
	-- c counts the appearance of the substring of the word in the line, k counts the character position
	local c, k = 1, 1
	while k &gt; 0 do
		k = line:find(who, k)
		if k == nil then return; end
		c = c + 1

		if k == line:find(&quot;%f[%a]&quot;..who..&quot;%f[%A]&quot;, k) then
			if selectString(who, c-1) &gt; -1 then
				if color     then fg(color) end
				if bold      then setBold(true) end
				if underline then setUnderline(true) end
				if italicize then setItalics(true) end
				resetFormat()
			else return end
		end

--		k = k + #who
		k = k + 1
	end
end</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>ndb.loadhighlights</name>
                    <packageName></packageName>
                    <script></script>
                    <eventHandlerList>
                        <string>m&amp;m system loaded</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>ndb.addhighlightname</name>
                    <packageName></packageName>
                    <script>function ndb.addhighlightname(_, name)
  if not name then return end -- no name is passed on a suicided person

  local person = ndb.getname(name)

  if not person then return end -- in case a person was deleted

  ndb.singlehighlight(name,
      person.org or &quot;&quot;,
      person.order or &quot;&quot;,
      person.orgenemy or 0,
      person.orderenemy or 0,
      person.guildenemy or 0,
      mm.me.watchfor[person.name],
      person.immortal or 0)
end</script>
                    <eventHandlerList>
                        <string>NameDB finished honors</string>
                        <string>m&amp;m watchfor name changed</string>
                        <string>NameDB highlightignore name changed</string>
                        <string>NameDB set name changed</string>
                        <string>NameDB saw list name</string>
                        <string>NameDB name deleted</string>
                    </eventHandlerList>
                </Script>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>ndb.API</name>
                <packageName></packageName>
                <script>--ndb.API

function ndb.isglom(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.org, &quot;Glomdoring&quot;), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.ismag(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.org, &quot;Magnagora&quot;), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.iscelest(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.org, &quot;New Celest&quot;), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.ishalli(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.org, &quot;Hallifax&quot;), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.isgaudi(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.org, &quot;Gaudiguch&quot;), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.isseren(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.org, &quot;Serenwilde&quot;), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.isclass(name, class)
  name, class = name:title(), class:lower()
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.class, class), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.getclass(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, &quot;name not known&quot; end

  return r[1].class:lower()
end

function ndb.setclass(name, class)
  class = class:lower()
  assert(ndb.isvalidclass(class), &quot;ndb.setclass: invalid class given&quot;)

  ndb.fixed_set(ndb.db.people.class, class, db:eq(ndb.db.people.name, name))
end

function ndb.getorg(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, &quot;name not known&quot; end

  return r[1].org
end

function ndb.getnotes(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, &quot;name not known&quot; end

  return r[1].notes
end

function ndb.isdemigod(name)
  assert(name, &quot;ndb.isdemigod() requires a name&quot;)

  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, &quot;name not known&quot; end

  return (r[1].demigod == 1 and true or false)
end

function ndb.setdemigod(name, status)
  status = mm.toboolean(status) and 1 or 0

  ndb.fixed_set(ndb.db.people.demigod, status, db:eq(ndb.db.people.name, name))
end

function ndb.isimmortal(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, &quot;name not known&quot; end

  return (r[1].immortal == 1 and true or false)
end

function ndb.exists(name)
  return #(db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))) ~= 0
end

function ndb.isperson(name)
  return #(db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))) ~= 0
end

-- returns true only if a certain enemy
function ndb.isenemy(name)
  local p = ndb.getname(name)
  if not p then return false end

  local org = p.org

  -- -1 autodetected, 1 enemy, 2 ally
  if p.iff == 1 or
       (p.iff ~= 2 and (org and org ~= &quot;&quot; and ndb.conf.orgpolitics[org] ~= &quot;ally&quot;) and
         ((org and org ~= &quot;&quot; and ndb.conf.orgpolitics[org] == &quot;enemy&quot;) or
         (p.orgenemy == 1 or p.orderenemy == 1 or p.guildenemy == 1))
       )
  then
    return true else return false
  end
end

-- returns true only if someone is an enemy via iff or is a org enemy. They could be a guild enemy, and not be considered an enemy by this
function ndb.isorgenemy(name)
  local p = ndb.getname(name)
  if not p then return false end

  local org = p.org

  -- -1 autodetected, 1 enemy, 2 ally
  if p.iff == 1 or
       (p.iff ~= 2 and
         ((org and org ~= &quot;&quot; and ndb.conf.orgpolitics[org] == &quot;enemy&quot;) or
         (p.orgenemy == 1))) then
    return true else return false
  end
end

-- given a title, returns all info about a person
function ndb.getnamebytitle (title)
  return db:fetch(ndb.db.people, db:in_(ndb.db.people.name, string.split(title, &quot; &quot;)))
end

-- given a line, returns the first name it finds, if any
function ndb.findname(line)
  for w in string.gmatch(line, &quot;(%u%l+)&quot;) do
    if #w &gt;= 3 then
      if ndb.isperson(w) then return w end
    end
  end
end

-- given a line, returns all names found on it
function ndb.findnames(line)
  local l = {}
  for w in string.gmatch(line, &quot;(%u%l+)&quot;) do
    if #w &gt;= 3 then
      if ndb.isperson(w) then l[#l+1] = w end
    end
  end

  if l[1] then return l end
end

-- given a name, returns all info about a person
function ndb.getname (name)
  return db:fetch(ndb.db.people, db:eq(ndb.db.people.name, string.title(name)))[1]
end

--  &quot;Magnagora&quot;, &quot;New Celest&quot;, &quot;Hallifax&quot;, &quot;Gaudiguch&quot;, &quot;Glomdoring&quot;, &quot;Serenwilde&quot;
local singular_org = {
  [&quot;&quot;]           = &quot;Rogue&quot;,
  [&quot;New Celest&quot;] = &quot;Celestian&quot;,
  Gaudiguch      = &quot;Gaudi&quot;,
  Glomdoring     = &quot;Glom&quot;,
  Hallifax       = &quot;Halli&quot;,
  Magnagora      = &quot;Mag&quot;,
  Serenwilde     = &quot;Seren&quot;
}

local plural_org = {
  [&quot;&quot;]           = &quot;Rogues&quot;,
  [&quot;New Celest&quot;] = &quot;Celestians&quot;,
  Gaudiguch      = &quot;Gaudis&quot;,
  Glomdoring     = &quot;Gloms&quot;,
  Hallifax       = &quot;Hallis&quot;,
  Magnagora      = &quot;Mags&quot;,
  Serenwilde     = &quot;Serens&quot;
}

local singular_class = {}

local plural_class = {
  [&quot;aeromancer&quot;]   = &quot;aeromancers&quot;,
  [&quot;aquamancer&quot;]   = &quot;aquamancers&quot;,
  [&quot;blacktalon&quot;]   = &quot;blacktalon&quot;,
  [&quot;cacophonist&quot;]  = &quot;cacophony&quot;,
  [&quot;cantor&quot;]       = &quot;cantors&quot;,
  [&quot;celestine&quot;]    = &quot;celestines&quot;,
  [&quot;ebonguard&quot;]    = &quot;ebonguard&quot;,
  [&quot;geomancer&quot;]    = &quot;geomancers&quot;,
  [&quot;harbinger&quot;]    = &quot;harbingers&quot;,
  [&quot;hartstone&quot;]    = &quot;hartstone&quot;,
  [&quot;illuminati&quot;]   = &quot;illuminati&quot;,
  [&quot;researcher&quot;]   = &quot;researchers&quot;,
  [&quot;minstrel&quot;]     = &quot;minstrels&quot;,
  [&quot;moondancer&quot;]   = &quot;moondancers&quot;,
  [&quot;nekotai&quot;]      = &quot;nekotai&quot;,
  [&quot;nihilist&quot;]     = &quot;nihilists&quot;,
  [&quot;ninjakari&quot;]    = &quot;ninjakari&quot;,
  [&quot;paladin&quot;]      = &quot;paladins&quot;,
  [&quot;pyromancer&quot;]   = &quot;pyromancers&quot;,
  [&quot;sentinel&quot;]     = &quot;sentinels&quot;,
  [&quot;serenguard&quot;]   = &quot;serenguards&quot;,
  [&quot;shadowdancer&quot;] = &quot;shadowdancers&quot;,
  [&quot;shofangi&quot;]     = &quot;shofangi&quot;,
  [&quot;spiritsinger&quot;] = &quot;spiritsingers&quot;,
  [&quot;symphonist&quot;]   = &quot;symphonists&quot;,
  [&quot;tahtetso&quot;]     = &quot;tahtetso&quot;,
  [&quot;templar&quot;]      = &quot;templars&quot;,
  [&quot;ur'guard&quot;]     = &quot;ur'guards&quot;,
}

local contains = table.contains
for class in pairs(plural_class) do if not table.contains(ndb.valid.classes, class) then mm.echof(&quot;Warning: %s as defined in plural_class is missing from ndb.valid.classes. Seems like a mistake?&quot;) end end

function ndb.getpluralclass(class, count)
  class = class:lower()
  if count &lt;= 1 then
    return class
  else
    return plural_class[class]
  end
end

function ndb.getpluralorg(org, count)
  if count &lt;= 1 then
    return singular_org[org]
  else
    return plural_org[org]
  end
end

function ndb.getcolor(name)
  assert(type(name) == &quot;string&quot;, &quot;ndb.getcolor: name to get a color of is required&quot;)

  local person = ndb.getname(name)

  if not person then return &quot;&quot; end -- in case the person doesn't exist

  local city, conf, color = person.org, mm.conf

  -- order of priority: watchfor &gt; divine &gt; city &gt; order &gt; house &gt; citizens.  
  if city == &quot;&quot; or not city then city = false else city = city:lower() end -- known rogues are returned as &quot;&quot;
  if city == &quot;new celest&quot; then city = &quot;newcelest&quot; end

  -- color first
  if conf.highlightwatchfor and mm.me.watchfor[name] then
    color     = conf.watchforcolor or &quot;a_darkwhite&quot;

  elseif conf.highlightdivine and person.immortal == 1 then
    color     = conf.divinecolor or &quot;a_darkwhite&quot;

  elseif conf.highlightcity and person.cityenemy == 1 then
    color     = conf.citycolor or &quot;a_darkwhite&quot;

  elseif conf.highlightorder and person.orderenemy == 1 then
    color     = conf.ordercolor or &quot;a_darkwhite&quot;

  elseif conf.highlighthouse and person.houseenemy == 1 then
    color     = conf.housecolor or &quot;a_darkwhite&quot;

  elseif order and conf[&quot;highlight&quot;..order] then
    color     = conf[order..&quot;color&quot;] or &quot;a_darkwhite&quot;

  elseif city and conf[&quot;highlight&quot;..city] then
    color     = conf[city..&quot;color&quot;] or &quot;a_darkwhite&quot;
  end

  return (color and '&lt;'..color..'&gt;' or &quot;&quot;)
end

function ndb.getcolorp(name)
  assert(type(name) == &quot;string&quot;, &quot;ndb.getcolor: name to get a color of is required&quot;)

  local person = ndb.getname(name)

  if not person then return &quot;&quot; end -- in case the person doesn't exist

  local city, conf, color = person.org, mm.conf

  -- order of priority: watchfor &gt; divine &gt; city &gt; order &gt; house &gt; citizens.  
  if city == &quot;&quot; then city = false else city = city:lower() end -- known rogues are returned as &quot;&quot;

  -- color first
  if conf.highlightwatchfor and mm.me.watchfor[name] then
    color     = conf.watchforcolor or &quot;a_darkwhite&quot;

  elseif conf.highlightdivine and person.immortal == 1 then
    color     = conf.divinecolor or &quot;a_darkwhite&quot;

  elseif conf.highlightcity and person.cityenemy == 1 then
    color     = conf.citycolor or &quot;a_darkwhite&quot;

  elseif conf.highlightorder and person.orderenemy == 1 then
    color     = conf.ordercolor or &quot;a_darkwhite&quot;

  elseif conf.highlighthouse and person.houseenemy == 1 then
    color     = conf.housecolor or &quot;a_darkwhite&quot;

  elseif order and conf[&quot;highlight&quot;..order] then
    color     = conf[order..&quot;color&quot;] or &quot;a_darkwhite&quot;

  elseif city and conf[&quot;highlight&quot;..city] then
    color     = conf[city..&quot;color&quot;] or &quot;a_darkwhite&quot;
  end

  return color
end

for _, format in ipairs{&quot;bold&quot;, &quot;underline&quot;, &quot;italicize&quot;} do
  ndb[&quot;should&quot;..format] = function(name)
    assert(type(name) == &quot;string&quot;, &quot;ndb.should&quot;..format..&quot;: name to get a color of is required&quot;)

    local person = ndb.getname(name)

    if not person then return false end -- in case the person doesn't exist

    local city, conf, color = person.org, mm.conf

    return (conf[format..&quot;watchfor&quot;] and mm.me.watchfor[name])    or 
           (conf[format..&quot;city&quot;] and person.cityenemy == 1)        or
           (conf[format..&quot;order&quot;] and person.orderenemy == 1)      or
           (conf[format..&quot;house&quot;] and person.houseenemy == 1)      or
           (conf[format..&quot;divine&quot;] and person.immortal == 1)       or
           (order and conf[format..order])                         or
           (city == &quot;&quot; and conf[format..&quot;rogues&quot;])                 or
           (city and conf[format..city])
  end
end

function ndb.addname(name)
  local temp_name_list = {}

  if type(name) == &quot;table&quot; then
    for i = 1, #name do
      temp_name_list[#temp_name_list+1] = {name = name[i]:title()}
    end
  else
    temp_name_list = {{name = name:title()}}
  end

  db:merge_unique(ndb.db.people, temp_name_list)

  raiseEvent(&quot;NameDB got new data&quot;)
end

function ndb.setiff(name, status)
  local name = name:lower():title()

  local category = &quot;iff&quot;
  local towhat

  -- -1 autodetected, 1 enemy, 2 ally
  local status = status:lower()
  if status == &quot;enemy&quot; then
    towhat = 1
  elseif status == &quot;ally&quot; then
    towhat = 2
  else
    towhat = -1
  end

  local temp_name_list = {{
    name = name,
    [category] = towhat
  }}

  db:merge_unique(ndb.db.people, temp_name_list)
end</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>ndb.aliases</name>
                <packageName></packageName>
                <script>function ndb.showwhois(whom)
  local data = ndb.getname(whom)

  if not data then mm.echof(&quot;I'm afraid we don't know person named %s.&quot;, matches[2]:title()) mm.showprompt() return end

  if data.immortal == 0 then
    cecho(&quot;\n&lt;a_darkblue&gt;--&lt;purple&gt;(m&amp;m) &lt;a_grey&gt;&quot;..data.name..&quot;'s (&quot;..data.gender:sub(1,1)..&quot;) NameDB profile&lt;a_darkblue&gt;&quot; .. (&quot;-&quot;):rep(55-#data.name) .. &quot;\n&quot;)
    cecho(&quot;&lt;a_darkcyan&gt;  Orgs:\n&quot;)
    cecho(string.format(&quot;&lt;a_darkgrey&gt;    Guild: %-23s Org:        %s (cr%s)\n&quot;,
      (data.guild == '' and 'unknown' or data.guild),
      (data.org == '' and 'unknown' or data.org),
      (data.org_rank == 0 and '?' or data.org_rank)
    ))

    cecho(string.format(&quot;&lt;a_darkgrey&gt;    Order: %s\n&quot;,
      (data.order == '' and 'unknown' or data.order)
    ))

    cecho(&quot;\n&lt;a_darkcyan&gt;  Personal:\n&quot;)
    cecho(string.format(&quot;&lt;a_darkgrey&gt;    Class:  %-15s        XP rank:    %s\n&quot;,
      (data.class == '' and 'unknown' or data.class),
      (data.xp_rank == -2 and 'unranked' or (data.xp_rank == -1 and 'unknown' or data.xp_rank))
    ))
    cecho(string.format(&quot;&lt;a_darkgrey&gt;    Might:  %-10s             Importance: %s\n&quot;,
      (data.might == -1 and 'unranked' or data.might),
      (data.importance == 0 and 'unset' or data.importance)
    ))
    cecho(string.format(&quot;&lt;a_darkgrey&gt;    Demigod: %-9s             Race:       %s\n&quot;,
      (data.demigod == 1 and 'yep' or 'nope'),
      (data.race == '' and 'unknown' or data.race)
    ))
    cecho(string.format(&quot;&lt;a_darkgrey&gt;    Has laurels: %s\n&quot;,
      (data.laurels == 1 and 'yep' or 'nope')
    ))

    cecho(&quot;\n&lt;a_darkcyan&gt;  Status to you:\n&quot;)
    cecho(string.format(&quot;&lt;a_darkgrey&gt;    Org enemy:   %-10s        Guild enemy: %s\n&quot;,
      (data.orgenemy == 0 and 'nope' or 'yep'),
      (data.guildenemy == 0 and 'nope' or 'yep')
    ))

    cecho(string.format(&quot;&lt;a_darkgrey&gt;    Order enemy: %-11s       \n&quot;,
      data.orderenemy == 0 and 'nope' or 'yep'
    ))

    local currenstatus
    if data.iff == -1 then
      if ndb.isenemy(data.name) then currenstatus = &quot;enemy (auto)&quot;
      else currenstatus = &quot;ally (auto)&quot; end
    end

    cecho(string.format(&quot;&lt;a_darkgrey&gt;    Actual status to you: %s\n&quot;,
      (data.iff == -1 and currenstatus or (data.iff == 1 and &quot;enemy (manual)&quot; or &quot;ally (manual)&quot;))
    ))
  else
    cecho(&quot;\n&lt;a_darkblue&gt;--&lt;purple&gt;(m&amp;m) &lt;a_grey&gt;&quot;..data.name..&quot;'s NameDB profile&lt;a_darkblue&gt;&quot; .. (&quot;-&quot;):rep(55-#data.name) .. &quot;\n&quot;)
    cecho(&quot;\n&lt;a_darkcyan&gt;    They are an Immortal.\n&quot;)
  end

  cecho(&quot;\n&lt;a_darkcyan&gt;  Notes (&quot;)
  setUnderline(true)
  fg(&quot;a_darkcyan&quot;)
  echoLink(&quot;edit&quot;, 'printCmdLine&quot;ndb set '..whom:title()..' notes '..data.notes:gsub(&quot;\n&quot;, [[\\n]])..'&quot;', 'Click to edit the notes you have on '..whom:title()..' - you can use \\n for a linebreak, and &lt;color&gt; to color text', true)
  resetFormat()
  cecho(&quot;&lt;a_darkcyan&gt;):\n&quot;)
  cecho(string.format(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;&quot;..((data.notes and data.notes ~= &quot;&quot;) and data.notes:gsub(&quot;\n&quot;, &quot;\n    &lt;a_blue&gt;-&lt;reset&gt; &quot;) or &quot;none yet&quot;)..&quot;\n&quot;))
  deselect() fg(&quot;a_darkblue&quot;) echo(string.rep(&quot;-&quot;, 80)) resetFormat() echo'\n'
  mm.showprompt()
end

function ndb.exportmenu()
  mm.echof(&quot;Exporting works in 3 steps:\n&quot;)

  setFgColor(unpack(mm.getDefaultColorNums))
  echo(&quot;a) select what data about people you'd like to export:\n&quot;)
  for key, _ in pairs(ndb.exportdata.fields) do
    echo(&quot;  &quot;)

    if key == &quot;name&quot; then
      echoLink(&quot;[X] name&quot;, [[mm.echof(&quot;The name has to stay, otherwise what'll be there to import?&quot;)]], &quot;If you'd just like to share the list of names known, you can tick everything else off and leave this on&quot;, true)
    else
      echoLink(&quot;[&quot;..(ndb.exportdata.fields[key] and 'X' or ' ')..'] '..key,
        [[ndb.exportdata.fields.]]..key..[[ = ]]..tostring(not ndb.exportdata.fields[key])..[[;ndb.exportmenu()]],
        'Click to '..(not ndb.exportdata.fields[key] and 'add' or 'remove') .. ' '..key .. ' for export', true)
    end
    echo(&quot;\n&quot;)
  end

  echo(&quot;\n&quot;)
  echo(&quot;b) select which people you'd like to export:\n&quot;)
  for key, _ in pairs(ndb.exportdata.people) do
    setFgColor(unpack(mm.getDefaultColorNums))
    echo(&quot;  &quot;)

    echoLink(&quot;[&quot;..(ndb.exportdata.people[key] and 'X' or ' ')..'] '..key,
      [[ndb.exportdata.people.]]..key..[[ = ]]..tostring(not ndb.exportdata.people[key])..[[;ndb.exportmenu()]],
      (ndb.exportdata.people[key] and 'Click to export '..key or 'Click not to export '..key), true)

    echo(&quot;\n&quot;)
  end

  echo(&quot;\n&quot;)
  echo(&quot;d) select a folder to export to: &quot;)
  setUnderline(true)
  echoLink((not ndb.exportdata.location and &quot;&lt;folder&gt;&quot; or ndb.exportdata.location), [[
    ndb.exportdata.location = invokeFileDialog(false, &quot;Where do you want to save the file? Select it and click Open&quot;)
    if ndb.exportdata.location == &quot;&quot; then ndb.exportdata.location = false end
    ndb.exportmenu()]],
    '', true)
  setUnderline(false)
  echo(&quot;\n&quot;)

  echo(&quot;\n&quot;)
  mm.echofn(&quot;All set? &quot;)

  setUnderline(true)
  setFgColor(unpack(mm.getDefaultColorNums))
  echoLink(&quot;Export!&quot;, (not ndb.exportdata.location and 'mm.echof(&quot;Pick a folder to export to, silly.&quot;)' or 'ndb.doexport()'), 'Click to export', true)
  setUnderline(false)
end

function ndb.importmenu()
  mm.echof(&quot;Import NameDB data:&quot;)

  setFgColor(unpack(mm.getDefaultColorNums))
  echo(&quot;\n&quot;)
  if not ndb.importdata.location then echo(&quot;a) select a file to import: &quot;) else echo(&quot;a) file to import: &quot;) end
  setUnderline(true)
  echoLink((not ndb.importdata.location and &quot;&lt;file&gt;&quot; or ndb.importdata.location), [[
    ndb.importdata.location = invokeFileDialog(true, &quot;Pick the file you'd like to import and select Open&quot;)
    if ndb.importdata.location == &quot;&quot; then ndb.importdata.location = false end
    if ndb.importdata.location then ndb.getimportfields() end
    ndb.importmenu()]],
    '', true)
  setUnderline(false)
  echo(&quot;\n&quot;)

  echo(&quot;\n&quot;)
  if not ndb.importdata.data then
    echo(&quot;b) select which fields to import once you've picked a file&quot;)
  else
    echo(&quot;b) select which fields to import:\n&quot;)
    for key, _ in pairs(ndb.importdata.fields) do
      echo(&quot;  &quot;)

      if key == &quot;name&quot; then
        echoLink(&quot;[X] name&quot;, [[mm.echof(&quot;The name has to stay, otherwise how will the import data make sense?&quot;)]], &quot;The persons name - this has to stay&quot;, true)
      else
        echoLink(&quot;[&quot;..(ndb.importdata.fields[key] and 'X' or ' ')..'] '..key,
          [[ndb.importdata.fields.]]..key..[[ = ]]..tostring(not ndb.importdata.fields[key])..[[;ndb.importmenu()]],
          'Click to '..(not ndb.importdata.fields[key] and 'add' or 'remove') .. ' '..key .. ' for import', true)
      end
      echo(&quot;\n&quot;)
    end
  end
  echo(&quot;\n&quot;)

  echo(&quot;\n&quot;)
  mm.echofn(&quot;All set? &quot;)

  setUnderline(true)
  setFgColor(unpack(mm.getDefaultColorNums))
  echoLink(&quot;Import!&quot;, (not ndb.importdata.data and 'mm.echof(&quot;Pick a file to import first!&quot;)' or 'ndb.doimport()'), 'Click to import', true)
  setUnderline(false)
  echo(&quot;\n&quot;)
end

function ndb.checkqw(suffix, how)
  if ndb.qwtimer then killTimer(ndb.qwtimer) end

  enableTrigger(&quot;NameDB qw&quot;)
  ndb.qwtimer = tempTimer(3, function() disableTrigger(&quot;NameDB qw&quot;); ndb.qwtimer = nil end)
  ndb.qwtype = how

  send(&quot;qw&quot;..(suffix and suffix or ''), false)
end</script>
                <eventHandlerList/>
            </Script>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>Third-party</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>Pluralization</name>
                    <packageName></packageName>
                    <script>--
-- MySQL Workbench Doctrine Export Plugin
-- Version: 0.3.6
-- Authors: Johannes Mueller, Karsten Wutzke
-- Copyright (c) 2008-2009
--
-- http://code.google.com/p/mysql-workbench-doctrine-plugin/
--
-- This file is free software: you can redistribute it and/or
-- modify it under the terms of the GNU Lesser General Public
-- License as published by the Free Software Foundation, either
-- version 3 of the License, or (at your option) any later version.
--
-- This library is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-- Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public
-- License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
--

function string.endswith(s, suffix)
    return s:sub(#s - #suffix + 1) == suffix
end

function isPlural(s)
    -- is plural if string ends with an &quot;s&quot; but not with &quot;ss&quot;
    return string.endswith(s, &quot;s&quot;) and not string.endswith(s, &quot;ss&quot;) and #s &gt; 1
end

function isSingular(s)
    -- is singular if not plural
    return not isPlural(s)
end

function string.singularize(s)

    -- is plural?
    if ( isPlural(s) ) then
        -- strip &quot;s&quot;
        s = string.sub(s, 1, #s - 1)

        -- we can't just strip the s without looking at the remaining English plural endings
        -- see http://en.wikipedia.org/wiki/English_plural

        -- if the table name ends with &quot;e&quot; (&quot;coache&quot;, &quot;hashe&quot;, &quot;addresse&quot;, &quot;buzze&quot;, &quot;heroe&quot;, ...)
        if (    string.endswith(s, &quot;che&quot;)
             or string.endswith(s, &quot;she&quot;)
             or string.endswith(s, &quot;sse&quot;)
             or string.endswith(s, &quot;zze&quot;)
             or string.endswith(s, &quot;oe&quot;) ) then

            -- strip an &quot;e&quot;, too
            s = string.sub(s, 1, #s - 1)

        -- if table name ends with &quot;ie&quot;
        elseif ( string.endswith(s, &quot;ie&quot;) ) then
            -- replace &quot;ie&quot; by a &quot;y&quot; (&quot;countrie&quot; -&gt; &quot;country&quot;, &quot;hobbie&quot; -&gt; &quot;hobby&quot;, ...)
            s = string.sub(s, 1, #s - 2) .. &quot;y&quot;

        elseif ( string.endswith(s, &quot;ve&quot;) ) then
            -- replace &quot;ve&quot; by an &quot;f&quot; (&quot;calve&quot; -&gt; &quot;calf&quot;, &quot;leave&quot; -&gt; &quot;leaf&quot;, ...)
            s = string.sub(s, 1, #s - 2) .. &quot;f&quot;

            -- does *not* work for certain words (&quot;knive&quot; -&gt; &quot;knif&quot;, &quot;stave&quot; -&gt; &quot;staf&quot;, ...): TODO (hard)
        else
            -- do nothing (&quot;game&quot;, &quot;referee&quot;, &quot;monkey&quot;, ...)

            -- note: table names like &quot;Caches&quot; can't be handled correctly because of the &quot;che&quot; rule above,
            -- that word however basically stems from French and might be considered a special case anyway
            -- also collective names like &quot;Personnel&quot;, &quot;Cast&quot; (caution: SQL keyword!) can't be singularized
        end
    end

    return s
end

function string.pluralize(s)

    -- is singular?
    if ( isSingular(s) ) then

        -- we can't just append the s without looking at the English singular endings
        -- see http://en.wikipedia.org/wiki/English_plural

        -- if the table name ends with &quot;ch&quot;, &quot;sh&quot;, &quot;ss&quot; or &quot;zz&quot; (&quot;coach&quot;, &quot;hash&quot;, &quot;address&quot;, &quot;buzz&quot;, &quot;hero&quot;, ...)
        if (    string.endswith(s, &quot;ch&quot;)
             or string.endswith(s, &quot;sh&quot;)
             or string.endswith(s, &quot;ss&quot;)
             or string.endswith(s, &quot;zz&quot;)
             or string.endswith(s, &quot;o&quot;) ) then

            -- append &quot;es&quot;
            s = s .. &quot;es&quot;

        -- if table name ends with &quot;y&quot;
        elseif ( string.endswith(s, &quot;y&quot;) ) then
            -- replace &quot;y&quot; with &quot;ies&quot; (&quot;country&quot; -&gt; &quot;countries&quot;, &quot;hobby&quot; -&gt; &quot;hobbies&quot;, ...)
            s = string.sub(s, 1, #s - 1) .. &quot;ies&quot;

        elseif ( string.endswith(s, &quot;f&quot;) ) then
            -- replace &quot;f&quot; by an &quot;ves&quot; (&quot;leaf&quot; -&gt; &quot;leaves&quot;, &quot;half&quot; -&gt; &quot;halves&quot;, ...)
            s = string.sub(s, 1, #s - 1) .. &quot;ves&quot;
        else
            -- append &quot;s&quot; (&quot;games&quot;, &quot;referees&quot;, &quot;monkeys&quot;, ...)
            s = s .. &quot;s&quot;
        end
    end

    return s
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Ordinal</name>
                    <packageName></packageName>
                    <script>function string.ordinalSuffix (n)
  n = math.mod (n, 100)
  local d = math.mod (n, 10)
  if d == 1 and n ~= 11 then
    return &quot;st&quot;
  elseif d == 2 and n ~= 12 then
    return &quot;nd&quot;
  elseif d == 3 and n ~= 13 then
    return &quot;rd&quot;
  else
    return &quot;th&quot;
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Stats</name>
                    <packageName></packageName>
                    <script>-- Small stats library                      --
----------------------------------------------
-- Version History --
-- 1.0 First written.

-- Tables supplied as arguments are not changed.


-- Table to hold statistical functions
stats={}

-- Get the mean value of a table
function stats.mean( t )
  local sum = 0
  local count = 0
  local type = type

  for k,v in pairs(t) do
    if type(v) == 'number' then
      sum = sum + v
      count = count + 1
    end
  end

  return (sum / count)
end

-- Get the mode of a table.  Returns a table of values.
-- Works on anything (not just numbers).
function stats.mode( t )
  local counts={}

  for k, v in pairs( t ) do
    if counts[v] == nil then
      counts[v] = 1
    else
      counts[v] = counts[v] + 1
    end
  end

  local biggestCount = 0

  for k, v  in pairs( counts ) do
    if v &gt; biggestCount then
      biggestCount = v
    end
  end

  local temp={}

  for k,v in pairs( counts ) do
    if v == biggestCount then
      table.insert( temp, k )
    end
  end

  return temp
end

-- Get the median of a table.
function stats.median( t )
  local temp={}

  -- deep copy table so that when we sort it, the original is unchanged
  -- also weed out any non numbers
  for k,v in pairs(t) do
    if type(v) == 'number' then
      table.insert( temp, v )
    end
  end

  table.sort( temp )

  -- If we have an even number of table elements or odd.
  if math.fmod(#temp,2) == 0 then
    -- return mean value of middle two elements
    return ( temp[#temp/2] + temp[(#temp/2)+1] ) / 2
  else
    -- return middle element
    return temp[math.ceil(#temp/2)]
  end
end


-- Get the standard deviation of a table
function stats.standardDeviation( t )
  local m
  local vm
  local sum = 0
  local count = 0
  local result

  m = stats.mean( t )

  for k,v in pairs(t) do
    if type(v) == 'number' then
      vm = v - m
      sum = sum + (vm * vm)
      count = count + 1
    end
  end

  result = math.sqrt(sum / (count-1))

  return result
end

-- Get the max and min for a table
function stats.maxmin( t )
  local max = -math.huge
  local min = math.huge

  for k,v in pairs( t ) do
    if type(v) == 'number' then
      max = math.max( max, v )
      min = math.min( min, v )
    end
  end

  return max, min
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
        </ScriptGroup>
    </ScriptPackage>
    <KeyPackage/>
    <HelpPackage>
        <helpURL></helpURL>
    </HelpPackage>
</MudletPackage>
