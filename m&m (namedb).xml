<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>NameDB</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>99</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Data Capture</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Lists</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>NameDB cwho</name>
						<script>temp_name_list = {}
temp_demigod = 0
ndb.temp_classes_list = {}
ndb.temp_guilds_list = {}

local lastline = getLines(getLineNumber()-1, getLineNumber())[1]

ndb.temp_cwho = {
  rank = lastline:find("Rank"),
  position = lastline:find("Position"),
  ct = lastline:find("CT"),
  class = lastline:find("Class"),
  offPlane = lastline:find("OffP"),
}</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>1</conditonLineDelta>
						<mStayOpen>100</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:Commune Member|Citizen)</string>
							<string>Rank</string>
							<string>Position</string>
							<string>CT</string>
							<string>-------------------------------------------------</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Get name (cwho)</name>
							<script>local line = line

local name = line:match("^(%w+)")
local class = line:sub(ndb.temp_cwho.class, ndb.temp_cwho.rank-1):trim()
local rank = line:sub(ndb.temp_cwho.rank, ndb.temp_cwho.position-1):trim()
local position = line:sub(ndb.temp_cwho.position-1, ndb.temp_cwho.ct-1):trim()

resetFormat()

temp_name_list[#temp_name_list + 1] = {
  name = name,
  org_rank = ndb.getorgrank(rank) or -1,
  org = ndb.getmyorg()
}


--local class = ndb.getclass(name)
--Adding guilds instead of class. Class is now shown by the game. Adding only a short name because smaller place available now
--Not adding guild name if name is over 14 characters long as that will take up more space than is available

local guild = ndb.getguild_shortname(name) or "None"
local demigod
if ndb.isdemigod then demigod = ndb.isdemigod(name) end


if #name &lt;= 14 and guild ~=""then 
	moveCursor(#name, getLineNumber())
	fg("DarkSlateGrey") insertText(string.format([[(%s)]], guild))

	resetFormat()
	-- delete extra spaces that got shifted over now
	if selectSection(#name+#guild+2, #guild+2) then replace("") end
	deselect()
end 	

if demigod then moveCursor(ndb.temp_cwho.rank-4, getLineNumber())
	fg("DarkSlateGrey") insertText("(h)") temp_demigod = temp_demigod+1
	resetFormat()
	if selectSection(ndb.temp_cwho.rank-1, 3) then replace("") end
	deselect()
end

resetFormat()

guild = ndb.getguild(name)
ndb.temp_classes_list[class] = (ndb.temp_classes_list[class] or 0) + 1
ndb.temp_guilds_list[guild] = (ndb.temp_guilds_list[guild] or 0) + 1</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>return not isPrompt() and not line:starts("-") and not line:starts("*") and not line:starts("Currently, there")</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>4</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Stop getting (cwho)</name>
							<script>setTriggerStayOpen("NameDB cwho", 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent("NameDB saw list name", person.name)
end

if next(ndb.temp_classes_list) then
  local classes = mm.keystolist(ndb.temp_classes_list)
  table.sort(classes)

  for i = 1, #classes do
    classes[i] = ndb.temp_classes_list[classes[i]] .. " "..(ndb.temp_classes_list[classes[i]] == 1 and classes[i] or string.pluralize(classes[i]))
  end

  moveCursor(0, getLineNumber())
  mm.itf("%s present, of those %s %s demigod%s/ascendant%s.\n", mm.concatand(classes), temp_demigod, (temp_demigod == 1 and 'is a' or 'are'), (temp_demigod == 1 and '' or 's'), (temp_demigod == 1 and '' or 's'))
  moveCursorEnd()
  ndb.temp_classes_list = nil
end


if next(ndb.temp_guilds_list) then

  local guilds = mm.keystolist(ndb.temp_guilds_list)
  table.sort(guilds)

  for i = 1, #guilds do
    guilds[i] = ndb.temp_guilds_list[guilds[i]] .. " from " ..guilds[i]:title()
  end

  moveCursor(0, getLineNumber())

  mm.itf("%s are on visible planes.\n",mm.concatand(guilds))
  moveCursorEnd()
  ndb.temp_guilds_list = nil
end


temp_name_list = nil
ndb.temp_cwho = nil

raiseEvent("NameDB got new data")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Currently, there</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>2</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Moar!!!</name>
							<script>send("more")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Type MORE</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>2</integer>
							</regexCodePropertyList>
						</Trigger>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>NameDB gwho</name>
						<script>temp_name_list = {}</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>1</conditonLineDelta>
						<mStayOpen>100</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Guildmember</string>
							<string>Rank</string>
							<string>Position</string>
							<string>GT</string>
							<string>GNT</string>
							<string>CGT</string>
							<string>----------------------------</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>2</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Get name (gwho)</name>
							<script>temp_name_list[#temp_name_list + 1] = {
  name = multimatches[1][2],
  guild = rex.match(gmcp.Char.Status.guild, [[^(\w+)]])
}

</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(\w+)</string>
								<string>return not line:find("^Currently")</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>4</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Stop getting (gwho)</name>
							<script>setTriggerStayOpen("NameDB gwho", 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent("NameDB saw list name", person.name)
end

temp_name_list = nil

raiseEvent("NameDB got new data")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>return isPrompt()</string>
								<string>Currently,</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>4</integer>
								<integer>2</integer>
							</regexCodePropertyList>
						</Trigger>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Citizens/Members</name>
						<script>local templist = string.split(multimatches[3][1], ",")

for i,k in pairs(templist) do
	templist[i] = k:trim()
end

-- last on name on list might have a dot
if string.sub(templist[#templist], -1, -1) == "." then
	templist[#templist] = string.sub(templist[#templist], 1, -2)
end

ndb.tempnames = nil

local temp_name_list = {}

for i,j in ipairs(templist) do
	temp_name_list[#temp_name_list + 1] = {
		name = j,
		org = ndb.getmyorg()
	}
end

db:merge_unique(ndb.db.people, temp_name_list)

raiseEvent("NameDB got new data")

-- reload all highlights, as citizens list is big anyhow
ndb.loadhighlights()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>1</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^The following are ACTIVE (?:citizens|commune members) of .+\:$</string>
							<string>1</string>
							<string>.+</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>5</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Guild members</name>
						<script>temp_name_list = {}

-- this can't be used: no name highlighting in the list done by Lusternia
-- this also has reference to ndb.isvalidclass. Does not work with new guilds. This is not being changed because this option has long been supressed and not been in use.
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>999</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>  GR Status Name + Title</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Get name (guild members)</name>
							<script>local match = getColorWildcard(14)

if match then
  if matches[2]:lower() == "demigod" then matches[2] = nil end

  temp_name_list[#temp_name_list + 1] = {
    name = match[1],
--    class = ((matches[2] and ndb.isvalidclass(matches[2])) and matches[2]:lower() or ""),
    guild = rex.match(gmcp.Char.Status.guild, [[^(\w+)]])
  }
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^ *\d+(?: prob)? +(\w+)\s+.*$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Stop getting (guild members)</name>
							<script>setTriggerStayOpen("Guild members", 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent("NameDB saw list name", person.name)
end

temp_name_list = nil

raiseEvent("NameDB got new data")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^\d+</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Order members</name>
						<script>temp_name_list = {}</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>2</conditonLineDelta>
						<mStayOpen>300</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>*******</string>
							<string>[ THE DIVINE ORDER OF</string>
							<string>Faithful</string>
							<string>--------</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
							<integer>0</integer>
							<integer>2</integer>
							<integer>0</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Member</name>
							<script>if matches[2] == "Type" or matches[2] == "There" or matches[2] == "You" then return end

temp_name_list[#temp_name_list + 1] = {
  name = matches[2],
  order = gmcp.Char.Status.order:match("^(%w+)")
}</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^([A-Za-z]+)\*?</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Update list on break</name>
							<script>db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent("NameDB saw list name", person.name)
end

temp_name_list = {}

raiseEvent("NameDB got new data")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Type MORE to continue reading.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>2</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Member list stop</name>
							<script>setTriggerStayOpen("Order members", 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent("NameDB saw list name", person.name)
end

temp_name_list = nil

raiseEvent("NameDB got new data")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^There are \w+ faithful in the Order\.$</string>
								<string>return isPrompt()</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>4</integer>
							</regexCodePropertyList>
						</Trigger>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>NameDB qw</name>
						<script>-- ignore yourself gemmed offplane
if multimatches[1][1] == "None." or multimatches[1][1] == "You can not sense a single person." then return end

-- all data is on the previous line
local data = multimatches[1][1]
data = string.split(data, ", ")

-- fix last name that ends with a dot
data[#data] = string.sub(data[#data], 1, #data[#data] - 1)

-- fix the 'and Name' from qw2
if data[#data]:starts("and ") then
  data[#data] = data[#data]:match("and (%w+)")
end

local temp_name_list = {}

for i = 1, #data do
  local name = data[i]

  name = name:gsub("%&lt;","")
  name = name:gsub("%(","")
  name = name:gsub("%)","")
  name = name:gsub("%&gt;","")
  -- check for guides
  if name:find("(", 1, true) then
    local secondname
    name, secondname = name:match("(%w+)%((%w+)%)")
	
    -- guides are in the format of Name(Name), some non-guides are just (Name)
    if secondname then temp_name_list[#temp_name_list + 1] = {name = secondname} end

    -- handle just (Name)
    if not name then name = data[i]:match("%((%w+)%)") end
  end

  temp_name_list[#temp_name_list + 1] = {name = name}
end

-- re-honors if asked for
if ndb.qwtype and ndb.qwtype == "update" then
  for _, name in pairs(temp_name_list) do
    name.might = -1
  end

-- or organize by orgs
elseif ndb.qwtype and ndb.qwtype == "organize orgs" then
  local orgs = {}

  local getorg = ndb.getorg
  for _, person in pairs(temp_name_list) do
    local org = getorg(person.name)

    org = org or "unknown"
    if org == "" then org = "rogue" end

    if ndb.isimmortal(person.name) then org = "Immortal" end

    orgs[org] = orgs[org] or {}
    orgs[org][#orgs[org]+1] = person.name
  end

  echo'\n\n'
  mm.echof("qw, sorted by members and count:")

  local sortbycount, longestorgname = {}, 0
  for org, members in pairs(orgs) do
    sortbycount[org] = #members
    if #org &gt; longestorgname then longestorgname = #org end
  end

  local sortbycount = {}; for org in pairs(orgs) do sortbycount[#sortbycount+1] = {org, #orgs[org]} end
  table.sort(sortbycount, function(a, b)
    return a[2] &gt; b[2]
  end)

  for _, org in ipairs(sortbycount) do
    local org, members = org[1], orgs[org[1]]
    table.sort(members)
    cecho(string.format("  &lt;royal_blue&gt;%-"..longestorgname.."s&lt;a_grey&gt; &lt;DarkSlateGrey&gt;(&lt;blaze_orange&gt;%d&lt;DarkSlateGrey&gt;): &lt;a_grey&gt;%s\n", org, #members, mm.concatand(members)))
  end

-- or report to cc
elseif ndb.qwtype and ndb.qwtype:starts("report members of ") then
  local wanted = ndb.qwtype:match("^report members of (%w+)"):lower()

  local citizens = {}
  for _, org in ipairs(ndb.valid.orgs) do
    if org:lower():starts(wanted) then
      wanted = org

      for _, person in pairs(temp_name_list) do
        local persons_org = ndb.getorg(person.name)
        if persons_org == org then citizens[#citizens+1] = person.name end
      end

      break
    end
  end

  if not citizens[1] then echo'\n' mm.echof("No citizens of %s seem to be on.", wanted) return end

  table.sort(citizens)

  mm.cc("%s %s visible: %s", #citizens, ndb.getpluralorg(wanted, #citizens), mm.concatand(citizens))
end

db:merge_unique(ndb.db.people, temp_name_list)

raiseEvent("NameDB got new data")
disableTrigger("NameDB qw")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>1</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.*</string>
							<string>1</string>
							<string>^(?:\(\*\) Currently, there are|There are)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>5</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Org/Guild/Order enemies</name>
						<script>local field

if ndb.checkingenemies.command == "commune" or ndb.checkingenemies.command == "city" then
  ndb.fixed_set(ndb.db.people.orgenemy, 0)
  field = "org"
elseif multimatches[2][1]:find("Order") then
  ndb.fixed_set(ndb.db.people.orderenemy, 0)
  field = "order"
elseif multimatches[2][1]:find("Guild") then
  ndb.fixed_set(ndb.db.people.guildenemy, 0)
  field = "guild"
else
  mm.echof("Hm, problem - can't work out which orgs enemies are you looking at.")
end

local names = string.split(multimatches[4][1], ",")

for i = 1, #names do
  names[i] = names[i]:trim()
end

ndb.fixed_set(ndb.db.people[field.."enemy"], 1, db:in_(ndb.db.people.name, names))

-- reload all highlights
ndb.loadhighlights()

echo'\n'

if ndb.checkingenemies and ndb.checkingenemies.option then
  local temp_name_list = {}
  for i = 1, #names do
    temp_name_list[#temp_name_list + 1] = {
      name = names[i],
    }
  end

  db:merge_unique(ndb.db.people, temp_name_list)

  mm.echof(field:title().." enemies list updated, and new names added.")

  raiseEvent("NameDB got new data")
else
  mm.echof(field:title().." enemies list updated.")
end

disableTrigger("Org/Guild/Order enemies")
if ndb.checkingenemies then killTimer(ndb.checkingenemies[1]) end
ndb.checkingenemies = nil</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>3</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#00b300</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Enemies of the </string>
							<string>FG6BG2</string>
							<string>1</string>
							<string>.+</string>
							<string>1</string>
							<string>Total:</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
							<integer>6</integer>
							<integer>5</integer>
							<integer>1</integer>
							<integer>5</integer>
							<integer>2</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Birthdays list</name>
						<script>-- this can't be used: no name highlighting in the list done by Lusternia

bdayTable = bdayTable or {}
bdayTable[#bdayTable+1] = matches[2]

mm.prompttrigger("namedb capture birtdhdays", function()
	local temp_name_list = {}

	for i,j in ipairs(bdayTable) do
		temp_name_list[#temp_name_list + 1] = {
			name = j
		}
	end

	db:merge_unique(ndb.db.people, temp_name_list)

	raiseEvent("NameDB got new data")
	bdayTable = nil
end)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(\w+) is \d+ years old today!$</string>
							<string>^The soul of (\w+) is \d+ years old today!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>ClairSentience</name>
						<script>temp_name_list = {}</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>20</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You gently coax the wind into telling you its secrets, and attempt to discern the locations of other Ascendants:</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Ascendant</name>
							<script>temp_name_list[#temp_name_list + 1] = {name = matches[2]}</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You distantly sense (\w+)</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>End (ClairSentience)</name>
							<script>setTriggerStayOpen("ClairSentience", 0)

db:merge_unique(ndb.db.people, temp_name_list)

temp_name_list = nil

raiseEvent("NameDB got new data")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>return isPrompt()</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>4</integer>
							</regexCodePropertyList>
						</Trigger>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Allies/enemies list (namedb)</name>
						<script>temp_name_list = {}</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>999</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You consider the following adventurers your allies:</string>
							<string>You consider the following adventurers your enemies:</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>3</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Person</name>
							<script>temp_name_list[#temp_name_list + 1] = {name = matches[2]}</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You feel an unusually strong lust for (\w+)\.$</string>
								<string>^(\w+) is an ally\.$</string>
								<string>^(\w+) is an enemy\.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Stop (allies list)</name>
							<script>setTriggerStayOpen("Allies/enemies list (namedb)", 0)

db:merge_unique(ndb.db.people, temp_name_list)

temp_name_list = nil

raiseEvent("NameDB got new data")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>return isPrompt()</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>4</integer>
							</regexCodePropertyList>
						</Trigger>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Scent (namedb)</name>
						<script>temp_name_list = {}</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>999</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You scent at the air, your skilled nose picking up the faint traces of others in the surrounding area.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Person</name>
							<script>temp_name_list[#temp_name_list + 1] = {name = matches[2]}</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You make out the scent of (\w+)</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>End (scent)</name>
							<script>setTriggerStayOpen("Scent (namedb)", 0)

db:merge_unique(ndb.db.people, temp_name_list)

temp_name_list = nil

raiseEvent("NameDB got new data")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>return isPrompt()</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>4</integer>
							</regexCodePropertyList>
						</Trigger>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Various common things</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Channel history</name>
						<script>ndb.temp_name_list = {}</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>1000</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Most recent communication for the</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>A line</name>
							<script>if matches[2] ~= "Someone" then
  ndb.temp_name_list[#ndb.temp_name_list + 1] = {
    name = matches[2]
  }
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^\d+ ?\) (\w+)</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>End (channel history)</name>
							<script>setTriggerStayOpen("Channel history", 0)

db:merge_unique(ndb.db.people, ndb.temp_name_list)

ndb.temp_name_list = nil

raiseEvent("NameDB got new data")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>return isPrompt()</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>4</integer>
							</regexCodePropertyList>
						</Trigger>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Newbie spawned - guild fledglings</name>
						<script>local temp_name_list = temp_name_list or {}

temp_name_list[#temp_name_list + 1] = {
  name = multimatches[2][2],
  org = ndb.getmyorg()
}

db:merge_unique(ndb.db.people, temp_name_list)

mm.prompttrigger("new data, don't erase line", function() raiseEvent("NameDB got new data") end)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(Fledglings): Please welcome</string>
							<string>^\(Fledglings\): Please welcome (\w+) who has graduated from .+ and joins as a novice freshman\!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Newbie spawned - city</name>
						<script>local temp_name_list = temp_name_list or {}

temp_name_list[#temp_name_list + 1] = {
  name = multimatches[2][2],
  org = ndb.getmyorg()
}

db:merge_unique(ndb.db.people, temp_name_list)

mm.prompttrigger("new data, don't erase line", function() raiseEvent("NameDB got new data") end)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(</string>
							<string>^\(\w+\): Please welcome (\w+) who just stepped out of the Portal of Fate as a new commune member!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Citizened a person</name>
						<script>local name = multimatches[2][2]

db:merge_unique(ndb.db.people, {{
  name = name,
  org = ndb.getmyorg(),
  org_rank = 1,
}})

mm.prompttrigger("new data, don't erase line", function() raiseEvent("NameDB got new data") end)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You ask</string>
							<string>^You ask (\w+) to repeat the oaths of .+ after you\.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Messages search</name>
						<script>-- disabled: this doesn't work great with admin / suicided persons

ndb.temp_name_list = {}</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>1</conditonLineDelta>
						<mStayOpen>999</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>   ID   Sender</string>
							<string>---------------</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
							<integer>2</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Message from a person</name>
							<script>ndb.temp_name_list[#ndb.temp_name_list + 1] = {
  name = matches[2]
}</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string> *\d+   ([A-Z][a-z]+)</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Messages search (end)</name>
							<script>setTriggerStayOpen("Messages search", 0)

db:merge_unique(ndb.db.people, ndb.temp_name_list)

ndb.temp_name_list = nil

raiseEvent("NameDB got new data")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>return isPrompt()</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>4</integer>
							</regexCodePropertyList>
						</Trigger>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Who here</name>
						<script>local names = multimatches[3][1]:split(", ")

local data = {}
for i = 1, #names do
  data[#data+1] = {name = names[i]}
end

db:merge_unique(ndb.db.people, data)

mm.prompttrigger("new data, don't erase line", function() raiseEvent("NameDB got new data") end)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>1</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You see the following people here:</string>
							<string>1</string>
							<string>.+</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>5</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Ascendant raised</name>
						<script>local temp_name_list = temp_name_list or {}

temp_name_list[#temp_name_list + 1] = {
  name = multimatches[2][2]
}

db:merge_unique(ndb.db.people, temp_name_list)

mm.prompttrigger("new data, don't erase line", function() raiseEvent("NameDB got new data") end)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A new Ascendant rises!</string>
							<string>^A new Ascendant rises! By decree of .+? and with full support of .+?, let it be known that .+? has this day imbued (\w+) with the energies of .+?, raising a Vernal Ascendant!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Honors on a person</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Honors</name>
						<script>if ndb.honorsid then killTimer(ndb.honorsid) end

temp_name_list = {}
temp_name_list[1] = {
  name = ndb.honorsname, demigod = 0,
  guildenemy = 0, orgenemy = 0, immortal = 0,
  gender = line:find("%f[%a][mM]ale%f[%A]") and 'male' or 'female',
  title = line:match("(.-) %(")
}

local brackets = line:match("%((.-)%)")
if brackets:find("%f[%a]God%f[%A]") or brackets:find("%f[%a]Goddess%f[%A]") or brackets:find("%f[%a]Ephemeral%f[%A]") then
  temp_name_list[1].immortal = 1
  temp_name_list[1].gender = ""
elseif brackets:find("Demigod",1,true) then
  temp_name_list[1].demigod = 1
end


ndb.honors_line_count = 0

local startline = getLineNumber()
for i = 1, 10 do -- word wrapping can mess it up, go so back a fair bit in case of small screen

  -- work backwards until the line with the name is located
  if string.find(getCurrentLine(), "%f[%a]"..ndb.honorsname.."%f[%A]") or getCurrentLine():starts("A small shrubbery") then
    -- pick up the race as it is listed
    local race = getCurrentLine():match("%(male (.-)%)") or getCurrentLine():match("%(female (.-)%)") or ""

    if ndb.isvalidrace(race) then
      temp_name_list[1].race = race:lower()
    end

    break
  end
  if ndb.gaghonours then deleteLine() end
  moveCursor(0, startline-i)
end
moveCursorEnd()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>100</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>return line:find("%f[%a]"..ndb.honorsname.."%f[%A]") and line:find("(", 1, true) and line:find(")", 1, true)</string>
							<string>A small shrubbery (</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>4</integer>
							<integer>2</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>XP rank</name>
							<script>temp_name_list[1].xp_rank = tonumber(matches[2])

-- 200 is a safe amount to set it at, as the number will vary
if tonumber(matches[2]) &lt; 200 then temp_name_list[1].demigod = 1 end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:She|He) is ranked (\d+)\w+ in Lusternia\.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Unranked</name>
							<script>temp_name_list[1].xp_rank = -2</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>He is unranked in Lusternia.</string>
								<string>She is unranked in Lusternia.</string>
								<string>He has cut his thread from the Tapestry of the Fates.</string>
								<string>She has cut her thread from the Tapestry of the Fates.</string>
								<string>He is frozen in time and space.</string>
								<string>She is frozen in time and space.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>3</integer>
								<integer>3</integer>
								<integer>3</integer>
								<integer>3</integer>
								<integer>3</integer>
								<integer>3</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Org &amp; rank</name>
							<script>local org = ndb.findfromtable(matches[3], ndb.valid.orgs)

if org then
  temp_name_list[1].org_rank = ndb.getorgrank(matches[2])
  temp_name_list[1].org = org
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:He|She) is a (.+?) in the (.+)?\.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Might</name>
							<script>temp_name_list[1].might = tonumber(matches[2])

-- toads are an It</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>87</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:She|He|It) is considered to be approximately (\d+)% of your might\.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Equal might</name>
							<script>temp_name_list[1].might = 100</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>He is considered to be approximately equal to your might.</string>
								<string>She is considered to be approximately equal to your might.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>3</integer>
								<integer>3</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Avatar</name>
							<script>temp_name_list[1].order = matches[2]</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>(?:He|She) is an Avatar of (\w+),</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>City/Commune enemy</name>
							<script>temp_name_list[1].orgenemy = 1</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>(?:He|She) is an enemy of your (?:commune|city)\.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Guildenemy</name>
							<script>temp_name_list[1].guildenemy = 1</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>He is an enemy of your guild.</string>
								<string>She is an enemy of your guild.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>3</integer>
								<integer>3</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Stop getting (honors)</name>
							<script>setTriggerStayOpen("Honors", 0)
disableTrigger("Honors")

-- didn't get honors - person has laurels?
if ndb.honors_line_count == 2 then
  -- don't erase namedb data with other false we might've collected then
  temp_name_list[1] = {laurels = 1, immortal = temp_name_list[1].immortal, gender = temp_name_list[1].gender, name = temp_name_list[1].name, demigod = temp_name_list[1].demigod}
end

db:merge_unique(ndb.db.people, temp_name_list)

local gaghonours = ndb.gaghonours
ndb.honorsid, ndb.gaghonours = nil, nil

raiseEvent("NameDB finished honors", temp_name_list[1].name, (gaghonours and "quiet" or "manual"))

temp_name_list = nil
ndb.honors_line_count = nil</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>return isPrompt()</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>4</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Any line</name>
							<script>if ndb.gaghonours then deleteLine() end

-- this can go off on the prompt when we're done with everything
if ndb.honors_line_count then
  ndb.honors_line_count = ndb.honors_line_count + 1
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>99</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>return true</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>4</integer>
							</regexCodePropertyList>
						</Trigger>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>No Honours</name>
						<script>if ndb.honorsid then killTimer(ndb.honorsid) ndb.honorsid = nil else return end

disableTrigger("Honors")

if ndb.gaghonours then mm.deleteLineP() end

echo("\n")
mm.echof(ndb.honorsname .. " doesn't exist anymore, deleted them.")

db:delete(ndb.db.people, db:eq(ndb.db.people.name, ndb.honorsname))

raiseEvent("NameDB name deleted", ndb.honorsname)

-- maintain a list of deleted people for getinfo to ignore, as the website still lists them: and thus getinfo re-adds them.
ndb.deletednames = ndb.deletednames or {}
ndb.deletednames[ndb.honorsname] = true

local gaghonours = ndb.gaghonours
ndb.gaghonours = nil

raiseEvent("NameDB finished honors", "", (gaghonours and "quiet" or "manual"))</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>There is no such person, I'm afraid.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Immortal</name>
						<script>if ndb.honorsid then killTimer(ndb.honorsid) ndb.honorsid = nil end

disableTrigger("Honors")

if ndb.gaghonours then mm.deleteLineP() end

local temp_name_list = {}
temp_name_list[1] = {name = ndb.honorsname, immortal = 1}
db:merge_unique(ndb.db.people, temp_name_list)

local gaghonours = ndb.gaghonours
ndb.gaghonours = nil

raiseEvent("NameDB finished honors", ndb.honorsname, (gaghonours and "quiet" or "manual"))</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>She was born before time was counted.</string>
							<string>He was born before time was counted.</string>
							<string>Administrators are here to adjudicate issues and are responsible for addressing game mechanics. Administrators do not have a roleplaying function.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>3</integer>
							<integer>3</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>NameDB</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Who is</name>
				<script>ndb.showwhois(matches[2]:lower())</script>
				<command></command>
				<packageName></packageName>
				<regex>^whois (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Honors a person</name>
				<script>ndb.honors(matches[2], "manual")</script>
				<command></command>
				<packageName></packageName>
				<regex>^honou?rs? (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb set person category value) Adjust person data</name>
				<script>local name = matches[2]:title()
local category = matches[3]
local towhat = tonumber(matches[4]) or matches[4]

local temp_name_list = {}

if category == "city" or category == "commune" then category = "org" end

if category == "org" then
  towhat = towhat:title()
  towhat = (towhat == "New celest") and "New Celest" or towhat

  if not ndb.isvalidorg(towhat) then
    mm.echof("%s isn't a known org, sorry.\n  Available ones are: %s", towhat, mm.concatand(ndb.valid.orgs))
    return
  end

elseif category == "class" then
  towhat = towhat:lower()
  if not ndb.isvalidclass(towhat) then
    mm.echof("%s isn't a known class, sorry.\n  Available ones are: %s", towhat, mm.concatand(ndb.valid.classes))
    return
  end

elseif category == "race" then
  towhat = towhat:lower()
  if not ndb.isvalidrace(towhat) then
    mm.echof("%s isn't a known race, sorry.\n  Available ones are: %s", towhat, mm.concatand(ndb.valid.races))
    return
  end

end

if category == "guild" or category == "order" then towhat = towhat:title() end
if category == "notes" then towhat = towhat:gsub([[\n]], "\n") end

if category == "orgenemy" or category == "guildenemy" or category == "orderenemy" or category == "immortal" or category == "demigod" or category == "laurels" then
  towhat = mm.toboolean(towhat) and 1 or 0
end

temp_name_list[#temp_name_list + 1] = {
  name = name,
  [category] = towhat
}

db:merge_unique(ndb.db.people, temp_name_list)

ndb.showwhois(name)

-- re-honors person if necessary
if category == "xp_rank" or category == "might" then
  raiseEvent"NameDB got new data"
end

raiseEvent("NameDB set name changed", name)

-- regenerate order mmconfigs
if category == "order" then ndb.setuporders() end</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb set (\w+) ([a-z_]+) (.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(iff person status)</name>
				<script>ndb.setiff(matches[2], matches[3])

ndb.showwhois(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^iff (\w+) (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>qw/qw2</name>
				<script>ndb.checkqw(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^qw(2)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(qw update) Re-check people on qw list</name>
				<script>ndb.checkqw(nil, "update")</script>
				<command></command>
				<packageName></packageName>
				<regex>^qw update$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(qwc) Organize by org members</name>
				<script>ndb.checkqw(nil, "organize orgs")</script>
				<command></command>
				<packageName></packageName>
				<regex>^qwc$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ppof) Report visible citizens of an org</name>
				<script>ndb.checkqw(nil, "report members of "..matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^ppof (\w+)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(npp) Toggle name highlighting</name>
				<script>mm.config.set("ndbpaused", matches[2], true)</script>
				<command></command>
				<packageName></packageName>
				<regex>^npp(?: (\w+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb stats) See DB stats</name>
				<script>mm.echof("Compiling database stats...")
mm.showprompt()

local function makestats()
  local alldata = db:fetch(ndb.db.people)

  if not alldata or not next(alldata) then mm.echof("Your NameDB is empty! Check 'qw', 'citizens' to start filling it up...") return end

  local totalcount = #alldata

  local orgs = {}
  for i = 1, #alldata do
    local p = alldata[i]
    if not p.org or p.org == '' then p.org = "none" end
    orgs[p.org] = orgs[p.org] or {}
    orgs[p.org][#orgs[p.org]+1] = p.name
  end
  local orgssorted = {}; for org in pairs(orgs) do orgssorted[#orgssorted+1] = {org, #orgs[org]} end
  table.sort(orgssorted, function(a, b)
    return a[2] &gt; b[2]
  end)

  echo'\n'
  mm.echof("People in the DB: %s", totalcount)
  mm.echof("Org stats:")
  for i = 1, #orgssorted do
    cecho(string.format("  %-15s - %d citizens.\n", orgssorted[i][1], orgssorted[i][2]))
  end

  mm.showprompt()
end

tempTimer(0, makestats)</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb stats$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb cancel) Cancel honors'ing people</name>
				<script>ndb.cancelhonors()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb cancel$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb honorsnew) Honors backlog of new people</name>
				<script>ndb.manualcheck = true
ndb.updatebyhonors()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb honorsnew$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb export) export DB</name>
				<script>-- keep the location used between exports
local oldlocation = false
if ndb.exportdata and ndb.exportdata.location then oldlocation = ndb.exportdata.location end

ndb.exportdata = {
  fields = {},
  people = {all = true},
  location = oldlocation
}

-- setup defaults
for key, _ in pairs(ndb.schema.people) do
  if key:sub(1,1) ~= "_" then ndb.exportdata.fields[key] = true end
end
ndb.exportdata.fields.notes = false

ndb.exportmenu()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb export$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb import) import DB</name>
				<script>-- keep the location used between imports
local oldlocation = false
if ndb.importdata and ndb.importdata.location then oldlocation = ndb.importdata.location end

ndb.importdata = {
  location = oldlocation,
  data = false,
  fields = {},
}

if ndb.importdata.location then ndb.getimportfields() end
ndb.importmenu()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb import$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb delete all) Wipe the database clean</name>
				<script>if not ndb.deleteall then
  mm.echof("Are you really sure you want to wipe the database completely clean? Nothing will be saved, and this is irreversible. If yes, do this again.")
  mm.showprompt()
  ndb.deleteall = true
  return
end

ndb.deleteall = nil
db:delete(ndb.db.people, true)

-- clear highlights
ndb.loadhighlights()

mm.echof("Database completely wiped.")
mm.showprompt()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb delete all$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb update all) Re-check every person in the database</name>
				<script>local alldata = db:fetch(ndb.db.people)

if #alldata &gt;= 100 and not ndb.updateall then
  mm.echof("Are you really sure you want to re-check everybody in the database? You've got %d names - this'll take a while.", #alldata)
  mm.showprompt()
  ndb.updateall = true
  return
end

ndb.updateall = nil
ndb.fixed_set(ndb.db.people.might, -1)

mm.echof("Re-checking all %d known people in NameDB.", #alldata)
raiseEvent("NameDB got new data")</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb update all$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb delete person) Delete one individual entry</name>
				<script>if matches[2] == "all" then return end -- handled by another alias

local name = matches[2]:title()

local exists = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))

if not (exists and next(exists)) then mm.echof("%s doesn't exist in the database already.", name) mm.showprompt() return end

db:delete(ndb.db.people, db:eq(ndb.db.people.name, name))

raiseEvent("NameDB name deleted", name)

mm.echof("Deleted %s's entry from NameDB.", name)
mm.showprompt()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb delete (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(mmshow highlightignore) See people on highlightignore</name>
				<script>local l = (next(mm.me.highlightignore) and mm.oneconcat(mm.me.highlightignore) or "(none - use mmconfig highlightignore &lt;person&gt; to add)")
mm.echof("People on the highlightignore list: %s", l)
mm.showprompt()</script>
				<command></command>
				<packageName></packageName>
				<regex>^mmshow highlightignore$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Enemies lists</name>
				<script>if ndb.checkingenemies then killTimer(ndb.checkingenemies[1]) end

ndb.checkingenemies = {
  tempTimer(10+getNetworkLatency(), [[
    ndb.checkingenemies = nil
    disableTrigger"Org/Guild/Order enemies"
  ]]),
  option = (matches[3] and matches[3]:trim() or nil),
  command = matches[2]
}

enableTrigger"Org/Guild/Order enemies"
send(matches[2].." enemies", false)</script>
				<command></command>
				<packageName></packageName>
				<regex>^(city|commune|guild|order) enemies( add)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>ndb alias cheatsheet</name>
				<script>-- load help data in
local class = mm.me.class
if not ndb.help then
if not lfs.attributes(getMudletHomeDir().."/"..class.." m&amp;m") then
  mm.echof("You don't seem to have installed m&amp;m as a package in the name of \""..class.." m&amp;m\" - I can't find the ndb help file!")
  return
end

local f, msg = io.open(getMudletHomeDir().."/"..class.." m&amp;m/ndb-help.lua")
if not f then
  mm.echof("Didn't find the ndb-help.lua file in '"..getMudletHomeDir().."/"..class.." m&amp;m/ndb-help.lua".."' - I can't show you the aliases!")
  return
end

local s = f:read("*a")

   local data = loadstring("return "..s)()
	if not data then
		mm.echof("Couldn't load data from the ndb-help.lua file :/ maybe it is messed up.")
		return
	end

	ndb.help = data
end

local function gettooltip(entry)
  return table.concat(entry.definition, "\n")
end

local function getdesc(entry)
  return table.concat(entry.definition, "\n")
end

local function showshort()
	mm.echof("ndb alias cheatsheet:")

	for id, entry in pairs(ndb.help) do
		fg("DarkSlateGrey") echo"  * " setFgColor(unpack(mm.getDefaultColorNums)) echoLink(entry.term, 'ndb.showhelp('..id..')', gettooltip(entry), true) echo"\n"
	end
end

local function showlong()
	mm.echof("ndb alias cheatsheet (extended):")

	for id, entry in pairs(ndb.help) do
		fg("DarkSlateGrey") echo"  * " setFgColor(unpack(mm.getDefaultColorNums)) echoLink(entry.term, 'ndb.showhelp('..id..')', gettooltip(entry), true) echo"\n"
		echo"      " echo(getdesc(entry)) echo"\n"  echo"\n"
	end
end

if matches[2] then showlong() else showshort() end
mm.showprompt() echo'\n'</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb( long)?$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>NameDB</name>
			<packageName></packageName>
			<script>ndb = ndb or {}</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>ndb.init</name>
				<packageName></packageName>
				<script>ndb.schema = {
  people = {
    name        = "",
    title       = "",
    gender      = "",
    class       = "",
    org        = "",
    org_rank   = 0,
    guild       = "",
    might       = -1, -- 0 is a possible might, -1 unknown
    importance  = 0,
    xp_rank     = -1, -- -1 default, -2 unranked
    immortal    = 0,
    iff         = -1, -- -1 autodetected, 1 enemy, 2 ally
    orgenemy   = 0, -- 0 is not enemy, 1 is enemy
    orderenemy  = 0, -- 0 is not enemy, 1 is enemy
    guildenemy  = 0, -- 0 is not enemy, 1 is enemy
    order       = "",
    notes       = "",
    demigod     = 0,
    race        = "",
    laurels     = 0, -- laurels: remember this, so we don't honors them all the time

    _unique     = {"name"},
    _violations = "REPLACE"
  },
}

function ndb.init()
  ndb.db = db:create("NameDB", ndb.schema)
  -- necessary on Windows, because its IO tends to... slow down with time.
  -- http://www.sqlite.org/pragma.html#pragma_synchronous
  db.__conn["namedb"]:execute("pragma synchronous = OFF")

  -- shuffle Celestians into New Celest as they should be
  local c = #(db:fetch(ndb.db.people, db:eq(ndb.db.people.org, "Celest")))
  if c ~= 0 then
    -- wait for ndb.fixed_set to be loaded
    tempTimer(0, [[ndb.fixed_set(ndb.db.people.org, "New Celest", db:eq(ndb.db.people.org, "Celest")); mm.echof("Migrated ]]..c..[[ Celestians into New Celest as they should be.")]])
  end
end

ndb.init()</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>ndb.valid</name>
				<packageName></packageName>
				<script>ndb.valid = ndb.valid or {}

ndb.valid.orgs = {
  "Magnagora", "New Celest", "Hallifax", "Gaudiguch", "Glomdoring", "Serenwilde"
}
ndb.valid.classes = {
  "aeromancer", "aquamancer", "blacktalon", "cacophonist", "cantor", "celestine", "ebonguard", "geomancer", "harbinger", "hartstone", "illuminati", "researcher", "minstrel", "moondancer", "nekotai", "nihilist", "ninjakari", "paladin", "pyromancer", "sentinel", "serenguard", "shadowdancer", "shofangi", "spiritsinger", "symphonist", "tahtetso", "templar", "ur'guard",
}
ndb.valid.guilds = {
  "Listeners", "Sowers", "Wodewoses", "Swarm", "Auguries", "Thornwatch", "Archons", "Ecclesiarchy", "Sanctifiers", "Infernals", "Society", "Heralds", "Goonsquad", "Revelry", "Seekers", "Adherents", "Aerie", "Consortium ",
}
ndb.valid.guildsOLD = {
  "Aeromancers", "Aquamancers", "Blacktalon", "Cacophony", "Cantors", "Celestines", "Ebonguard", "Geomancers", "Harbingers", "Hartstone", "Illuminati", "Institute", "Minstrels", "Moondancers", "Nekotai", "Nihilists", "Ninjakari", "Paladins", "Pyromancers", "Sentinels", "Serenguard", "Shadowdancers", "Shofangi", "Spiritsingers", "Symphonium", "Tahtetso", "Templars", "Ur'Guard",
}
ndb.valid.races = {
  "human", "dwarf", "elfen", "dracnari", "faeling", "furrikin", "krokani", "aslaran", "loboshigaru", "mugwump", "merian", "orclach", "igasho", "tae'dae", "taurian", "trill", "viscanti", "lucidian", "kephera", "illithoid", "gnome", "fink", "nagasith", "sileni",
}

ndb.valid.guildtoclassOLD = {
  ["Ur'Guard"]  = "ur'guard",
  Aeromancers   = "aeromancer",
  Aquamancers   = "aquamancer",
  Blacktalon    = "blacktalon",
  Cacophony     = "cacophonist",
  Cantors       = "cantor",
  Celestines    = "celestine",
  Ebonguard     = "ebonguard",
  Geomancers    = "geomancer",
  Harbingers    = "harbinger",
  Hartstone     = "hartstone",
  Illuminati    = "illuminati",
  Institute     = "researcher",
  Minstrels     = "minstrel",
  Moondancers   = "moondancer",
  Nekotai       = "nekotai",
  Nihilists     = "nihilist",
  Ninjakari     = "ninjakari",
  Paladins      = "paladin",
  Pyromancers   = "pyromancer",
  Sentinels     = "sentinel",
  Serenguard    = "serenguard",
  Shadowdancers = "shadowdancer",
  Shofangi      = "shofangi",
  Spiritsingers = "spiritsinger",
  Symphonium    = "symphonist",
  Tahtetso      = "tahtetso",
  Templars      = "templar",
}

ndb.valid.classntoclassp = {
  ["Ur'Guard"]  = "ur'guard",
  Aeromancers   = "aeromancer",
  Aquamancers   = "aquamancer",
  Blacktalon    = "blacktalon",
  Cacophony     = "cacophonist",
  Cantors       = "cantor",
  Celestines    = "celestine",
  Ebonguard     = "ebonguard",
  Geomancers    = "geomancer",
  Harbingers    = "harbinger",
  Hartstone     = "hartstone",
  Illuminati    = "illuminati",
  Institute     = "researcher",
  Minstrels     = "minstrel",
  Moondancers   = "moondancer",
  Nekotai       = "nekotai",
  Nihilists     = "nihilist",
  Ninjakari     = "ninjakari",
  Paladins      = "paladin",
  Pyromancers   = "pyromancer",
  Sentinels     = "sentinel",
  Serenguard    = "serenguard",
  Shadowdancers = "shadowdancer",
  Shofangi      = "shofangi",
  Spiritsingers = "spiritsinger",
  Symphonium    = "symphonist",
  Tahtetso      = "tahtetso",
  Templars      = "templar",
}

ndb.valid.orgranks = {
  [1] = {"serf", "peasant", "ward"}, 
  [2] = {"laborer", "goodman", "goodwoman", "woman", "gardener"}, 
  [3] = {"supervisor", "nobleman", "noblewoman", "woodsman", "woodswoman",}, 
  [4] = {"master", "mistress", "lord", "lady", "forest custodian", }, 
  [5] = {"viscount", "viscountess", "count", "countess", "high forester",},
  [6] = {"marquis", "marquessa", "earl", "earless", "shadow warden", "dark seneschal", "forest warden", "guardian of the seren", "seneschal"},
}

ndb.valid.guildtoshort = {
 Listeners = "List",
 Sowers = "Sowe",
 Wodewoses = "Wode",
 Swarm = "Swa",
 Auguries = "Aug",
 Thornwatch = "TW",
 Archons = "Arch",
 Ecclesiarchy = "Eccl",
 Sanctifiers = "Sanc",
 Infernals = "Inf",
 Society = "Soc",
 Heralds = "Her",
 Goonsquad = "Goon",
 Revelry = "Rev",
 Seekers = "Seek",
 Adherents = "Adh",
 Aerie = "Aer",
 Consortium  = "Cons",
}

function ndb.isvalidorg(which)
  which = which:title()
  return table.contains(ndb.valid.orgs, which) and true or false
end

function ndb.isvalidclass(which)
  which = which:lower()
  return table.contains(ndb.valid.classes, which) and true or false
end

function ndb.isvalidguild(which)
  which = which:lower()
  return table.contains(ndb.valid.guilds, which) and true or false
end

function ndb.isvalidrace(which)
  which = which:lower()
  return table.contains(ndb.valid.races, which) and true or false
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>ndb.support</name>
				<packageName></packageName>
				<script>-- ndb.support

function ndb.tablemerge(t, other)
   for other_key, other_items in pairs(other) do
      if not t[other_key] then
         t[other_key] = other_items
      else
         local group = t[other_key]
         for item_key, item_value in pairs(other_items) do
            group[item_key] = item_value
         end
      end
   end
   return t
end

-- given a string and a table of possible answers, returns the first possible answer, if any
function ndb.findfromtable(input, data)
  local sfind = string.find

  for i = 1, #data do
    if sfind(input, data[i], 1, true) then return data[i] end
  end
end

function ndb.honors(name, type)
  if ndb.honorsid then mm.echof("ndb.honors() for %s called, when already honours'ing %s - not going to do this.", name:title(), ndb.honorsname:title()) return end
  name = name:lower():title()

  enableTrigger("Honors")

  if ndb.honorsid then killTimer(ndb.honorsid) end
  ndb.honorsid = tempTimer(2+getNetworkLatency(), function()
    disableTrigger("Honors")
    mm.echof("Honors on %s didn't happen - re-checking...", name)
    ndb.honorsid, ndb.gaghonours = nil, nil
    ndb.honors(name, type)
  end)

  ndb.honorsname = name
  send("honors " .. name, false) -- needs to full so it sees the clan listing

  if type == "quiet" then ndb.gaghonours = true end

  -- check up on their guild/org status while also HONORSing
  ndb.download2(name, false)
end

function ndb.cancelhonors(quietly)
  ndb.manualcheck = nil

  if (ndb.honorslist and next(ndb.honorslist)) or ndb.honorsid then
    ndb.honorslist = {}
    if ndb.honorsid then killTimer(ndb.honorsid) disableTrigger("Honors") end; ndb.honorsid = nil
    if not quietly then mm.echof("Cancelled honors-checking people.") end
  else
    if not quietly then mm.echof("Not checking anyone atm already.") end
  end
  if not quietly then mm.showprompt() end

  ndb.hidehonorswindow()
end

function ndb.getorgrank(rankname)
  rankname = rankname:lower()
  local contains = table.contains

  for rank, titles in ipairs(ndb.valid.orgranks) do
    if contains(titles, rankname) then return rank end
  end
end

-- -&gt; string
-- get own org name, with a special exception for translating Celest into New Celest
function ndb.getmyorg()
  local org = gmcp.Char.Status.city:match("^(%w+)")
  org = (org == "Celest" and "New Celest" or org)
  return org
end

-- update all info that we should be able to glean from honors.
-- might: if it's at -1, then it's default known
-- rank: -1 default unknown, -2 unranked
function ndb.updatebyhonors()
  local data = db:fetch(ndb.db.people, db:AND(db:not_eq(ndb.db.people.immortal, 1), db:not_eq(ndb.db.people.laurels, 1), db:OR(db:eq(ndb.db.people.xp_rank, -1), db:eq(ndb.db.people.might, -1))))

  ndb.honorslist = (function ()
    local t = {}
    for i,j in ipairs(data) do
      -- sanity check for weird names
      if j.name:find("^%u%l+$") then t[j.name] = true
      else db:delete(ndb.db.people, db:eq(ndb.db.people.name, j.name)) end
    end return t end)()

    if mm.conf.paused or not next(ndb.honorslist) then return end

    if not mm.conf.autohonors and not ndb.manualcheck then
      if table.size(ndb.honorslist) &gt; 1 then
        echo'\n'
        if table.size(ndb.honorslist) &lt;= 10 then
          mm.echofn("Got new names (%s), use '", mm.oneconcat(ndb.honorslist))
          setFgColor(unpack(mm.getDefaultColorNums))
          setUnderline(true)
          echoLink("ndb honorsnew", 'ndb.manualcheck = true; ndb.updatebyhonors()', 'Click to do ndb honorsnew', true)
          setUnderline(false)
          echo("' to check them.\n")
        else
          mm.echofn("Got %d new names, use '", table.size(ndb.honorslist))
          setFgColor(unpack(mm.getDefaultColorNums))
          setUnderline(true)
          echoLink("ndb honorsnew", 'ndb.manualcheck = true; ndb.updatebyhonors()', 'Click to do ndb honorsnew', true)
          setUnderline(false)
          echo("' to check them.\n")
        end
      end

      return
    end

    if table.size(ndb.honorslist) &lt;= 10 then
      echo'\n' mm.echof("Have new names (%s) - going to check them.", mm.oneconcat(ndb.honorslist))
    else
      echo'\n' mm.echof("Have %s new names - going to check them.", table.size(ndb.honorslist))
    end

  if not ndb.honorsid then ndb_honors_next() end
end

function ndb.doexport()
  if not ndb.exportdata.location then return nil, "no export location" end

  local alldata = db:fetch(ndb.db.people)

  if not alldata or not next(alldata) then mm.echof("Your NameDB is empty! Check 'qw', 'citizens' to start filling it up. There's nothing to export otherwise...") return end

  for i = 1, #alldata do
    local p = alldata[i]

    -- see if we need to prune the result first
    if not ndb.exportdata.people.all then
      alldata[i] = nil

    else
      -- prune fields we don't need
      for key,value in pairs(ndb.exportdata.fields) do
        if key ~= "name" and not value then p[key] = nil end
      end

      -- prune internal fields starting with underscores
      local removekeys = {}
      for key, _ in pairs(p) do
        if key:sub(1,1) == '_' then
          removekeys[#removekeys+1] = key
        end
      end

      for i = 1, #removekeys do p[removekeys[i]] = nil end
    end
  end

  -- build the final table that we'll table.save()
  local exportable = {
    meta = { author = mm.me.name, date = os.date("%A %d, %b '%y"), fields =  ndb.exportdata.fields },
    data = alldata
  }

  local location = string.format("%s/%s's namedb, %s", ndb.exportdata.location, mm.me.name, os.date("%A %d, %b '%y"))
  table.save(location, exportable)
  echo'\n' mm.echof("Data exported okay, it's in %s.", location)
end

-- reads selected files for fields available within it to import
function ndb.getimportfields()

  if not ndb.importdata.location or not io.exists(ndb.importdata.location) then ndb.importdata.location = nil; return end

  ndb.importdata.data = {}
  table.load(ndb.importdata.location, ndb.importdata.data)
  if not ndb.importdata.data then mm.echof("Couldn't read the file - maybe it's corrupted? Try another.") return end

  for k,v in pairs(ndb.importdata.data.meta.fields) do if ndb.schema.people[k] then ndb.importdata.fields[k] = true end end
end

function ndb.doimport()
  if not ndb.importdata.data then return nil, "no data loaded in ndb.importdata.data" end

  -- copy data over for importing with only the fields we need
  local temp_name_list = {}

  -- data.data as the original data is stored in .data of the new field that's imported.
  for i = 1, #ndb.importdata.data.data do
    local p = ndb.importdata.data.data[i]

    temp_name_list[#temp_name_list + 1] = {
      name = p.name,
    }

    for k,v in pairs(p) do
      if ndb.importdata.fields[k] then
        temp_name_list[#temp_name_list][k] = v
      end
    end
  end

  db:merge_unique(ndb.db.people, temp_name_list)
  mm.echof("Imported %d name%s okay.", #temp_name_list, (#temp_name_list == 1 and '' or 's'))

  raiseEvent("NameDB got new data")
  ndb.importdata.data = nil
end
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>ndb_honors_next</name>
					<packageName></packageName>
					<script>function ndb_honors_next(event, name, type)
	if mm.conf.paused or not ndb.honorslist then return end

	local name = next(ndb.honorslist)
	if not name then
		if type ~= "manual" then echo'\n' mm.echof("Done checking all new names.") mm.showprompt() end
		ndb.manualcheck = nil
		ndb.hidehonorswindow()
		return
	end

	if not mm.conf.autohonors and not ndb.manualcheck then return end

	ndb.honors(name, "quiet")
	ndb.honorslist[name] = nil
    local left = table.size(ndb.honorslist)
	--tempTimer(0, function() mm.echof("Checking %s, %s name%s left to check...\n", name, left, (left == 1 and '' or 's')) end)
	ndb.showhonorswindow(string.format("Checking %s, %s name%s left to check...\n", name, left, (left == 1 and '' or 's')))
end</script>
					<eventHandlerList>
						<string>NameDB finished honors</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.updatebyhonors</name>
					<packageName></packageName>
					<script>-- this just registers the handler, the script is supposed to be blank</script>
					<eventHandlerList>
						<string>NameDB got new data</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.ui</name>
					<packageName></packageName>
					<script>function ndb.showhonorswindow(text)
  ndb.autohonorslabel = ndb.autohonorslabel or Geyser.Label:new({
    name = "ndb.autohonorslabel",
    x = "-340px", y = "-35px",
    width = "320px", height = "25px",
  })

  ndb.autohonorslabel:setStyleSheet([[
    margin: 0px;
    padding: 2px;

    background: rgba(0, 0, 51, 75%);
    border: none;
    border-radius: 4px;

    qproperty-alignment: 'AlignLeft | AlignVCenter';
    qproperty-wordWrap: true;
    font-family: 'Ubuntu','Calibri',serif;
  ]])

  ndb.autohonorslabel:show()
  ndb.autohonorslabel:echo([[&lt;p style="color: grey; font-size: 15px;"&gt;]]..text..[[&lt;/p&gt;]])
end

function ndb.hidehonorswindow()
  if ndb.autohonorslabel then ndb.autohonorslabel:hide() end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.configs</name>
					<packageName></packageName>
					<script>function ndb.setuporders()
  local r = db:fetch_sql(ndb.db.people, [[SELECT DISTINCT "order" FROM 'people';]])
  if not r then return end

  table.sort(r, function(a,b) return a.order &lt; b.order end)

  for i = 1, #r do
    if r[i].order ~= "" then
      local order = r[i].order

      mm.config.setoption("highlight"..order:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s highlight %s's Order members.", mm.getDefaultColor(), order) end,
        ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s highlight %s's Order members.", mm.getDefaultColor(), order) end,
      })
      mm.config.setoption("bold"..order:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s bold %s's Order members.", mm.getDefaultColor(), order) end,
        ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s bold %s's Order members.", mm.getDefaultColor(), order) end,
      })
      mm.config.setoption("underline"..order:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s underline %s's Order members.", mm.getDefaultColor(), order) end,
        ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s underline %s's Order members.", mm.getDefaultColor(), order) end,
      })
      mm.config.setoption("italicize"..order:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s italicize %s's Order members.", mm.getDefaultColor(), order) end,
        ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s italicize %s's Order members.", mm.getDefaultColor(), order) end,
      })

      mm.config.setoption(order:lower().."color", {
        type = "string",
        check = function (what)
          if color_table[what] then return true end
        end,
        onset = function ()
          ndb.loadhighlights()
          local r,g,b = unpack(color_table[mm.conf[order:lower().."color"]])
          mm.echof("Highlighting %s Order members in &lt;%s,%s,%s&gt;%s%s now.", order, r,g,b, mm.conf[order:lower().."color"], mm.getDefaultColor())
        end,
      })
    end
  end
end

function ndb.configs()
  if mm.conf.autohonors == nil then mm.conf.autohonors = true end
  if mm.conf.ndbpause == nil then mm.conf.ndbpause = false end

  mm.config.setoption("autohonors", {
    type = "boolean",
    vconfig2string = true,
    onenabled = function () mm.echof("&lt;0,250,0&gt;Will%s automatically, and quietly, honors new people we come across.", mm.getDefaultColor()) ndb.updatebyhonors() end,
    ondisabled = function () mm.echof("&lt;250,0,0&gt;Won't%s automatically honors new people. Use 'ndb honorsnew' to clear the new names backlog manually.", mm.getDefaultColor()) ndb.cancelhonors(true) end,
    onshow = function (defaultcolour)
      fg("gold")
      echoLink("NameDB:", "", "m&amp;m NameDB", true)
      fg(defaultcolour) echo(" ")
      fg("a_cyan") echoLink(mm.conf.autohonors and "Auto-checking" or "Not auto-checking", "mm.config.set('autohonors', "..(mm.conf.autohonors and "false" or "true")..", true)", "Click to "..(mm.conf.autohonors and "disable" or "enable").." automatic honors checks on new people that we see", true)
      fg(defaultcolour)
      echo(" new people, highlighting names is ")
      fg(defaultcolour)
      fg("a_cyan") echoLink(not mm.conf.ndbpaused and "on" or "off", "mm.config.set('ndbpaused', "..(mm.conf.ndbpaused and "false" or "true")..", true)", "Click to "..(mm.conf.ndbpaused and "start" or "stop").." highlighting names", true)
      fg(defaultcolour)
      echo(".\n")
    end
  })

  mm.config.setoption("ndbpaused", {
    type = "boolean",
    onenabled = function () ndb.loadhighlights() mm.echof("Name highlighting &lt;250,0,0&gt;stopped%s.", mm.getDefaultColor()) end,
    ondisabled = function () ndb.loadhighlights() mm.echof("Name highlighting &lt;0,250,0&gt;resumed%s.", mm.getDefaultColor()) end
  })

  mm.conf.autoclassset = mm.conf.autoclassset or 10
  mm.config.setoption("autoclassset", {
    type = "number",
    vconfig2string = true,
    onshow = function (defaultcolour)
      fg("gold")
      echoLink("NameDB:", "", "m&amp;m NameDB", true)
      fg(defaultcolour) echo(" Capture a persons class after ")
      fg("a_cyan") echoLink(tostring(mm.conf.autoclassset), "printCmdLine('mmconfig autoclassset ')", "Click to set the amount of consecutive attacks a person must do from a particular class before it's recorded in NameDB. This is for anti-illusion purposes, so illusions can't easily make NameDB mess with their known class", true)
      fg(defaultcolour)
      echo(" consecutive attacks.\n")
    end
  })

  mm.config.setoption("politics", {
    type = "custom",
    onmenu = function () ndb.showpolitics(true) end,
  })

  local function setupwatchfor()
    mm.config.setoption("highlightwatchfor", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s highlight names on the watchfor list.", mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s highlight names on the watchfor list.", mm.getDefaultColor()) end,
    })
    mm.config.setoption("boldwatchfor", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s bold names on the watchfor list.", mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s bold names on the watchfor list.", mm.getDefaultColor()) end,
    })
    mm.config.setoption("underlinewatchfor", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s underline names on the watchfor list.", mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s underline names on the watchfor list.", mm.getDefaultColor()) end,
    })
    mm.config.setoption("italicizewatchfor", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s italicize names on the watchfor list.", mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s italicize names on the watchfor list.", mm.getDefaultColor()) end,
    })

    mm.config.setoption("watchforcolor", {
      type = "string",
      check = function (what)
        if color_table[what] then return true end
      end,
      onset = function ()
        ndb.loadhighlights()
        local r,g,b = unpack(color_table[mm.conf.watchforcolor])
        mm.echof("Highlighting watchfor names in &lt;%s,%s,%s&gt;%s%s now.", r,g,b, mm.conf.watchforcolor, mm.getDefaultColor())
      end,
    })
  end

  local function setuporgs()
    for _, org in ipairs(ndb.valid.orgs) do
      mm.config.setoption("highlight"..org:lower():gsub(" ", ""), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s highlight citizens of %s.", mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s highlight citizens of %s.", mm.getDefaultColor(), org) end,
      })
      mm.config.setoption("bold"..org:lower():gsub(" ", ""), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s bold the names of %s citizens.", mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s bold the names of %s citizens.", mm.getDefaultColor(), org) end,
      })
      mm.config.setoption("underline"..org:lower():gsub(" ", ""), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s underline the names of %s citizens.", mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s underline the names of %s citizens.", mm.getDefaultColor(), org) end,
      })
      mm.config.setoption("italicize"..org:lower():gsub(" ", ""), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s italicize the names of %s citizens.", mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s italicize the names of %s citizens.", mm.getDefaultColor(), org) end,
      })

      mm.config.setoption(org:lower():gsub(" ", "").."color", {
        type = "string",
        check = function (what)
          if color_table[what] then return true end
        end,
        onset = function ()
          ndb.loadhighlights()
          local r,g,b = unpack(color_table[mm.conf[org:lower():gsub(" ", "").."color"]])
          mm.echof("Highlighting %s citizens in &lt;%s,%s,%s&gt;%s%s now.", org, r,g,b, mm.conf[org:lower():gsub(" ", "").."color"], mm.getDefaultColor())
        end,
      })
    end
  end

  local function setuprogues()
    mm.config.setoption("highlightrogues", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s highlight rogues.", mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s highlight rogues.", mm.getDefaultColor()) end,
    })
    mm.config.setoption("boldrogues", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s bold the names of rogues.", mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s bold the names of rogues.", mm.getDefaultColor()) end,
    })
    mm.config.setoption("underlinerogues", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s underline the names of rogues.", mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s underline the names of rogues.", mm.getDefaultColor()) end,
    })
    mm.config.setoption("italicizerogues", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s italicize the names of rogues.", mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s italicize the names of rogues.", mm.getDefaultColor()) end,
    })

    mm.config.setoption("roguescolor", {
      type = "string",
      check = function (what)
        if color_table[what] then return true end
      end,
      onset = function ()
        ndb.loadhighlights()
        local r,g,b = unpack(color_table[mm.conf["roguescolor"]])
        mm.echof("Highlighting rogues in &lt;%s,%s,%s&gt;%s%s now.", r,g,b, mm.conf["roguescolor"], mm.getDefaultColor())
      end,
    })
  end

  local function setupenemies()
    for _, org in ipairs({"org", "guild", "order"}) do
      mm.config.setoption("highlight"..org:lower():gsub(" ", ""), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s highlight enemies of your of %s.", mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s highlight enemies of your of %s.", mm.getDefaultColor(), org) end,
      })
      mm.config.setoption("bold"..org:lower():gsub(" ", ""), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s bold the names of your %s enemies.", mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s bold the names of your %s enemies.", mm.getDefaultColor(), org) end,
      })
      mm.config.setoption("underline"..org:lower():gsub(" ", ""), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s underline the names of your %s enemies.", mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s underline the names of your %s enemies.", mm.getDefaultColor(), org) end,
      })
      mm.config.setoption("italicize"..org:lower():gsub(" ", ""), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s italicize the names of your %s enemies.", mm.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s italicize the names of your %s enemies.", mm.getDefaultColor(), org) end,
      })

      mm.config.setoption(org:lower():gsub(" ", "").."color", {
        type = "string",
        check = function (what)
          if color_table[what] then return true end
        end,
        onset = function ()
          ndb.loadhighlights()
          local r,g,b = unpack(color_table[mm.conf[org:lower():gsub(" ", "").."color"]])
          mm.echof("Highlighting your %s enemies in &lt;%s,%s,%s&gt;%s%s now.", org, r,g,b, mm.conf[org:lower():gsub(" ", "").."color"], mm.getDefaultColor())
        end,
      })
    end
  end

  local function setupdivines()
    mm.config.setoption("highlightdivine", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s highlight Divines.", mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s highlight Divines.", mm.getDefaultColor()) end,
    })
    mm.config.setoption("bolddivine", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s bold Divines.", mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s bold Divines.", mm.getDefaultColor()) end,
    })
    mm.config.setoption("underlinedivine", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s underline Divines.", mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s underline Divines.", mm.getDefaultColor()) end,
    })
    mm.config.setoption("italicizedivine", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() mm.echof("&lt;0,250,0&gt;Will%s italicize Divines.", mm.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() mm.echof("&lt;250,0,0&gt;Won't%s italicize Divines.", mm.getDefaultColor()) end,
    })

    mm.config.setoption("divinecolor", {
      type = "string",
      check = function (what)
        if color_table[what] then return true end
      end,
      onset = function ()
        ndb.loadhighlights()
        local r,g,b = unpack(color_table[mm.conf.divinecolor])
        mm.echof("Highlighting Divines in &lt;%s,%s,%s&gt;%s%s now.", r,g,b, mm.conf.divinecolor, mm.getDefaultColor())
      end,
    })
  end

  local function addhighlightignore()
    mm.me.highlightignore = mm.me.highlightignore or {}

    mm.config.setoption("highlightignore", {
      type = "string",
      check = function(what)
        if what:find("^%w+$") then return true end
      end,
      onset = function ()
        local name = string.title(mm.conf.highlightignore)
        -- we want nil, not false so 'or' doesn't help
        if mm.me.highlightignore[name] then mm.me.highlightignore[name] = nil else mm.me.highlightignore[name] = true end

        if mm.me.highlightignore[name] then
          mm.echof("Added &lt;0,255,0&gt;%s%s to the highlightignore list - so we won't highlight them.", name, mm.getDefaultColor())
        else
          mm.echof("Removed %s from the highlightignore list.", name)
        end
        raiseEvent("NameDB highlightignore name changed", name)
      end
    })
  end

  setuporgs()
  setuprogues()
  setupwatchfor()
  setupenemies()
  setupdivines()
  ndb.setuporders()
  addhighlightignore()
end

-- improve: add background colors
function ndb.showpolitics(noprompt)
  local echo, setFgColor, setUnderline, setFgColor, echoLink = echo, setFgColor, setUnderline, setFgColor, echoLink
  mm.echof("Adjust org stances and setup highlights (currently highlighting %s names):", table.size(ndb.highlightIDs))
  mm.echofn("(click on underlined to change, ")
    setFgColor(unpack(mm.getDefaultColorNums))
    setUnderline(true) echoLink("view color list", "showColors()", "Click here to view the list of possible colors you can choose", true) setUnderline(false)
    echo("):\n\n")

  local function showorgs()
    mm.echof("Org politics:")

    -- orgs
    for _, org in ipairs(ndb.valid.orgs) do
      local status = ndb.conf.orgpolitics[org]
      local extraspaces = 0
      setFgColor(unpack(mm.getDefaultColorNums))
      echo("  ")
      echo(string.format("%-10s is ", org))

      local nextstatus
      if status == "ally" then fg("a_green"); nextstatus = "enemy"; status = "an ally"; extraspaces = 7
      elseif status == "enemy" then fg("a_red"); nextstatus = "neutral"; status = "an enemy"; extraspaces = 8
      else fg("a_darkwhite"); nextstatus = "ally"; extraspaces = 7 end

      if mm.conf.org ~= org then
        setUnderline(true) echoLink(tostring(status), "ndb.conf.orgpolitics['"..org.."'] = '"..nextstatus.."'; ndb.showpolitics()", 'Click to set '..org.."s status to "..nextstatus, true) setUnderline(false)
      else
        setFgColor(unpack(mm.getDefaultColorNums)) echo("your home"); extraspaces = 9
      end

      setFgColor(unpack(mm.getDefaultColorNums))
      echo(",")
      echo((" "):rep(10-extraspaces))

      setUnderline(true)
      echoLink(mm.conf["highlight"..org:lower():gsub(" ", "")] and "highlighting" or "not highlighting",
        'mm.config.set("highlight'..org:lower():gsub(" ", "")..'", '..(mm.conf["highlight"..org:lower():gsub(" ", "")] and "false" or "true")..', true); ndb.showpolitics()',
        'Click to '..(mm.conf["highlight"..org:lower():gsub(" ", "")] and "stop" or "start").. ' highlighting citizens of '..org,
      true)
      setUnderline(false)

      if not mm.conf["highlight"..org:lower():gsub(" ", "")] then
        echo(" its citizens in any color,  ")
      else
        echo((" "):rep(4))
        echo(" its citizens in ")
        setUnderline(true)
        setFgColor(unpack(color_table[mm.conf[org:lower():gsub(" ", "").."color"] or "a_darkwhite"]))
        echoLink(mm.conf[org:lower():gsub(" ", "").."color"] or "a_darkwhite",
          "printCmdLine'mmconfig "..org:lower():gsub(" ", "").."color '",
          'Click to set the color of '..org..' citizens',
        true)
        setUnderline(false)
        setFgColor(unpack(mm.getDefaultColorNums))
        echo(",")
        echo((" "):rep(11-#(mm.conf[org:lower():gsub(" ", "").."color"] or "a_darkwhite")))
      end

      echo("(")

      setUnderline(true)
      echoLink(mm.conf["bold"..org:lower():gsub(" ", "")] and "bold" or "no bld",
        'mm.config.set("bold'..org:lower():gsub(" ", "")..'", '..(mm.conf["bold"..org:lower():gsub(" ", "")] and "false" or "true")..', true); ndb.showpolitics()',
        'Click to '..(mm.conf["bold"..org:lower():gsub(" ", "")] and "stop" or "start").. ' bolding citizens of '..org,
      true)
      setUnderline(false)
      echo(", ")

      setUnderline(true)
      echoLink(mm.conf["underline"..org:lower():gsub(" ", "")] and "undl" or "no undl",
        'mm.config.set("underline'..org:lower():gsub(" ", "")..'", '..(mm.conf["underline"..org:lower():gsub(" ", "")] and "false" or "true")..', true); ndb.showpolitics()',
        'Click to '..(mm.conf["underline"..org:lower():gsub(" ", "")] and "stop" or "start").. ' underlining citizens of '..org,
      true)
      setUnderline(false)
      echo(", ")

      setUnderline(true)
      echoLink(mm.conf["italicize"..org:lower():gsub(" ", "")] and "ital" or "no ital",
        'mm.config.set("italicize'..org:lower():gsub(" ", "")..'", '..(mm.conf["italicize"..org:lower():gsub(" ", "")] and "false" or "true")..', true); ndb.showpolitics()',
        'Click to '..(mm.conf["italicize"..org:lower():gsub(" ", "")] and "stop" or "start").. ' italicizing citizens of '..org,
      true)
      setUnderline(false)

      echo(")")

      echo('\n')
    end

    -- rogues
    setFgColor(unpack(mm.getDefaultColorNums))
    echo("  Rogues are neutral,      ")

    setUnderline(true)
    echoLink(mm.conf["highlightrogues"] and "highlighting" or "not highlighting",
      'mm.config.set("highlightrogues", '..(mm.conf["highlightrogues"] and "false" or "true")..', true); ndb.showpolitics()',
      'Click to '..(mm.conf["highlightrogues"] and "stop" or "start").. ' highlighting rogues',
    true)
    setUnderline(false)

    if not mm.conf["highlightrogues"] then
      echo(" them in any color,")
      echo((" "):rep(10))
    else
      echo((" "):rep(4))
      echo(" them in ")
      setUnderline(true)
      setFgColor(unpack(color_table[mm.conf["roguescolor"] or "a_darkwhite"]))
      echoLink(mm.conf["roguescolor"] or "a_darkwhite",
        "printCmdLine'mmconfig rogues".."color '",
        'Click to set the color of rogues',
      true)
      setUnderline(false)
      setFgColor(unpack(mm.getDefaultColorNums))
      echo(", ")
      echo((" "):rep(18-#(mm.conf["roguescolor"] or "a_darkwhite")))
    end

    echo("(")

    setUnderline(true)
    echoLink(mm.conf["boldrogues"] and "bold" or "no bld",
      'mm.config.set("boldrogues", '..(mm.conf["boldrogues"] and "false" or "true")..', true); ndb.showpolitics()',
      'Click to '..(mm.conf["boldrogues"] and "stop" or "start").. ' bolding rogues',
    true)
    setUnderline(false)
    echo(", ")

    setUnderline(true)
    echoLink(mm.conf["underlinerogues"] and "undl" or "no undl",
      'mm.config.set("underlinerogues", '..(mm.conf["underlinerogues"] and "false" or "true")..', true); ndb.showpolitics()',
      'Click to '..(mm.conf["underlinerogues"] and "stop" or "start").. ' underlining rogues',
    true)
    setUnderline(false)
    echo(", ")

    setUnderline(true)
    echoLink(mm.conf["italicizerogues"] and "ital" or "no ital",
      'mm.config.set("italicizerogues", '..(mm.conf["italicizerogues"] and "false" or "true")..', true); ndb.showpolitics()',
      'Click to '..(mm.conf["italicizerogues"] and "stop" or "start").. ' italicizing rogues',
    true)
    setUnderline(false)

    echo(")")

    echo('\n')
  end

  local function showwatchfor()
    mm.echof("Watchfor list:")
    setFgColor(unpack(mm.getDefaultColorNums))
    echo("  ")
    setUnderline(true)
    echoLink(mm.conf["highlightwatchfor"] and "Highlighting" or "Not highlighting",
      'mm.config.set("highlightwatchfor", '..(mm.conf["highlightwatchfor"] and "false" or "true")..', true); ndb.showpolitics()',
      'Click to '..(mm.conf["highlightwatchfor"] and "stop" or "start").. ' highlighting names on the watchfor list',
    true)
    setUnderline(false)

    if not mm.conf["highlightwatchfor"] then
      echo(" names on the watchfor list. ")
      echo((" "):rep(25))
    else
      echo(" names on the watchfor list in ")
      setUnderline(true)
      setFgColor(unpack(color_table[mm.conf["watchforcolor"] or "a_darkwhite"]))
      echoLink(mm.conf["watchforcolor"] or "a_darkwhite",
        "printCmdLine'mmconfig watchfor".."color '",
        'Click to set the color of names on the watchfor list',
      true)
      setUnderline(false)
      setFgColor(unpack(mm.getDefaultColorNums))
      echo(", ")
      echo((" "):rep(25-#(mm.conf["watchforcolor"] or "a_darkwhite")))
    end

    echo("(")

    setUnderline(true)
    echoLink(mm.conf["boldwatchfor"] and "bold" or "no bld",
      'mm.config.set("boldwatchfor", '..(mm.conf["boldwatchfor"] and "false" or "true")..', true); ndb.showpolitics()',
      'Click to '..(mm.conf["boldwatchfor"] and "stop" or "start").. ' bolding names on watchfor list',
    true)
    setUnderline(false)
    echo(", ")

    setUnderline(true)
    echoLink(mm.conf["underlinewatchfor"] and "undl" or "no undl",
      'mm.config.set("underlinewatchfor", '..(mm.conf["underlinewatchfor"] and "false" or "true")..', true); ndb.showpolitics()',
      'Click to '..(mm.conf["underlinewatchfor"] and "stop" or "start").. ' underlining names on watchfor list',
    true)
    setUnderline(false)
    echo(", ")

    setUnderline(true)
    echoLink(mm.conf["italicizewatchfor"] and "ital" or "no ital",
      'mm.config.set("italicizewatchfor", '..(mm.conf["italicizewatchfor"] and "false" or "true")..', true); ndb.showpolitics()',
      'Click to '..(mm.conf["italicizewatchfor"] and "stop" or "start").. ' italicizing names on watchfor list',
    true)
    setUnderline(false)

    echo(")")
    echo("\n")
  end

  local function showdivines()
    mm.echof("Divine list:")
    setFgColor(unpack(mm.getDefaultColorNums))
    echo("  ")
    setUnderline(true)
    echoLink(mm.conf["highlightdivine"] and "Highlighting" or "Not highlighting",
      'mm.config.set("highlightdivine", '..(mm.conf["highlightdivine"] and "false" or "true")..', true); ndb.showpolitics()',
      'Click to '..(mm.conf["highlightdivine"] and "stop" or "start").. ' highlighting Divines',
    true)
    setUnderline(false)

    if not mm.conf["highlightdivine"] then
      echo(" Divines. ")
      echo((" "):rep(44))
    else
      echo(" Divines in ")
      setUnderline(true)
      setFgColor(unpack(color_table[mm.conf["divinecolor"] or "a_darkwhite"]))
      echoLink(mm.conf["divinecolor"] or "a_darkwhite",
        "printCmdLine'mmconfig divine".."color '",
        'Click to set the color of Divine names',
      true)
      setUnderline(false)
      setFgColor(unpack(mm.getDefaultColorNums))
      echo(", ")
      echo((" "):rep(44-#(mm.conf["divinecolor"] or "a_darkwhite")))
    end

    echo("(")

    setUnderline(true)
    echoLink(mm.conf["bolddivine"] and "bold" or "no bld",
      'mm.config.set("bolddivine", '..(mm.conf["bolddivine"] and "false" or "true")..', true); ndb.showpolitics()',
      'Click to '..(mm.conf["bolddivine"] and "stop" or "start").. ' bolding Divines',
    true)
    setUnderline(false)
    echo(", ")

    setUnderline(true)
    echoLink(mm.conf["underlinedivine"] and "undl" or "no undl",
      'mm.config.set("underlinedivine", '..(mm.conf["underlinedivine"] and "false" or "true")..', true); ndb.showpolitics()',
      'Click to '..(mm.conf["underlinedivine"] and "stop" or "start").. ' underlining Divines',
    true)
    setUnderline(false)
    echo(", ")

    setUnderline(true)
    echoLink(mm.conf["italicizedivine"] and "ital" or "no ital",
      'mm.config.set("italicizedivine", '..(mm.conf["italicizedivine"] and "false" or "true")..', true); ndb.showpolitics()',
      'Click to '..(mm.conf["italicizedivine"] and "stop" or "start").. ' italicizing Divines',
    true)
    setUnderline(false)

    echo(")")
    echo("\n")
  end

  local function showenemies()
    mm.echof("Guild, Org and Order enemies:")

    for _, org in ipairs({"guild", "org", "order"}) do
      setFgColor(unpack(mm.getDefaultColorNums))
      echo("  ")
      setUnderline(true)
      echoLink(mm.conf["highlight"..org] and "Highlighting" or "Not highlighting",
        'mm.config.set("highlight'..org..'", '..(mm.conf["highlight"..org] and "false" or "true")..', true); ndb.showpolitics()',
        'Click to '..(mm.conf["highlight"..org] and "stop" or "start").. ' highlighting names of your '..org..' enemies',
      true)
      setUnderline(false)

      if not mm.conf["highlight"..org] then
        echo(" names of your "..org.." enemies. ")
        echo((" "):rep(29-#org))
      else
        echo("     names of your "..org.. " enemies in ")
        setUnderline(true)
        setFgColor(unpack(color_table[mm.conf[org.."color"] or "a_darkwhite"]))
        echoLink(mm.conf[org.."color"] or "a_darkwhite",
          "printCmdLine'mmconfig "..org.."color '",
          'Click to set the color of names on '..org..' enemies list',
        true)
        setUnderline(false)
        setFgColor(unpack(mm.getDefaultColorNums))
        echo(", ")
        echo((" "):rep(25-#org-#(mm.conf[org.."color"] or "a_darkwhite")))
      end

      echo("(")

      setUnderline(true)
      echoLink(mm.conf["bold"..org] and "bold" or "no bld",
        'mm.config.set("bold'..org..'", '..(mm.conf["bold"..org] and "false" or "true")..', true); ndb.showpolitics()',
        'Click to '..(mm.conf["bold"..org] and "stop" or "start").. ' bolding names of your '..org..' enemies',
      true)
      setUnderline(false)
      echo(", ")

      setUnderline(true)
      echoLink(mm.conf["underline"..org] and "undl" or "no undl",
        'mm.config.set("underline'..org..'", '..(mm.conf["underline"..org] and "false" or "true")..', true); ndb.showpolitics()',
        'Click to '..(mm.conf["underline"..org] and "stop" or "start").. ' underlining names of your '..org..' enemies',
      true)
      setUnderline(false)
      echo(", ")

      setUnderline(true)
      echoLink(mm.conf["italicize"..org] and "ital" or "no ital",
        'mm.config.set("italicize'..org..'", '..(mm.conf["italicize"..org] and "false" or "true")..', true); ndb.showpolitics()',
        'Click to '..(mm.conf["italicize"..org] and "stop" or "start").. ' italicizing names of your '..org..' enemies',
      true)
      setUnderline(false)

      echo(")")
      echo("\n")
    end
  end

  local function showordermembers()
    local r = db:fetch_sql(ndb.db.people, [[SELECT DISTINCT "order" FROM 'people';]])
    if not r then return end

    table.sort(r, function(a,b) return a.order &lt; b.order end)

    local shownsomething
    mm.echof("Order members:")
    for i = 1, #r do
      if r[i].order ~= "" then
        shownsomething = true
        local order = r[i].order

        setFgColor(unpack(mm.getDefaultColorNums))
        echo("  ")
        setUnderline(true)
        echoLink(mm.conf["highlight"..order:lower()] and "Highlighting" or "Not highlighting",
          'mm.config.set("highlight'..order:lower()..'", '..(mm.conf["highlight"..order:lower()] and "false" or "true")..', true); ndb.showpolitics()',
          'Click to '..(mm.conf["highlight"..order:lower()] and "stop" or "start").. ' highlighting names of '..order:lower()..'\'s members',
        true)
        setUnderline(false)

        if not mm.conf["highlight"..order:lower()] then
          echo(" names of "..order.."'s Order members. ")
          echo((" "):rep(26-#order))
        else
          echo("     names of "..order.. "'s Order members in ")
          setUnderline(true)
          setFgColor(unpack(color_table[mm.conf[order:lower().."color"] or "a_darkwhite"]))
          echoLink(mm.conf[order:lower().."color"] or "a_darkwhite",
            "printCmdLine'mmconfig "..order:lower().."color '",
            'Click to set the color of '..order:lower()..'\'s Order members',
          true)
          setUnderline(false)
          setFgColor(unpack(mm.getDefaultColorNums))
          echo(", ")
          echo((" "):rep(22-#order-#(mm.conf[order:lower().."color"] or "a_darkwhite")))
        end

        echo("(")

        setUnderline(true)
        echoLink(mm.conf["bold"..order:lower()] and "bold" or "no bld",
          'mm.config.set("bold'..order:lower()..'", '..(mm.conf["bold"..order:lower()] and "false" or "true")..', true); ndb.showpolitics()',
          'Click to '..(mm.conf["bold"..order:lower()] and "stop" or "start").. ' bolding names '..order:lower()..'\'s Order members',
        true)
        setUnderline(false)
        echo(", ")

        setUnderline(true)
        echoLink(mm.conf["underline"..order:lower()] and "undl" or "no undl",
          'mm.config.set("underline'..order:lower()..'", '..(mm.conf["underline"..order:lower()] and "false" or "true")..', true); ndb.showpolitics()',
          'Click to '..(mm.conf["underline"..order:lower()] and "stop" or "start").. ' underlining names '..order:lower()..'\'s Order members',
        true)
        setUnderline(false)
        echo(", ")

        setUnderline(true)
        echoLink(mm.conf["italicize"..order:lower()] and "ital" or "no ital",
          'mm.config.set("italicize'..order:lower()..'", '..(mm.conf["italicize"..order:lower()] and "false" or "true")..', true); ndb.showpolitics()',
          'Click to '..(mm.conf["italicize"..order:lower()] and "stop" or "start").. ' italicizing names '..order:lower()..'\'s Order members',
        true)
        setUnderline(false)

        echo(")")
        echo("\n")
      end
    end

    if not shownsomething then
      setFgColor(unpack(mm.getDefaultColorNums))
      echo("  (no members of Orders are known)")
      resetFormat()
      echo("\n")
    end
  end

  -- watchfor &gt; divine &gt; org &gt; order &gt; guild &gt; citizens
  showwatchfor()
  echo("\n")
  showdivines()
  echo("\n")
  showenemies()
  echo("\n")
  showordermembers()
  echo("\n")
  showorgs()

  if not noprompt then mm.showprompt() end
end</script>
					<eventHandlerList>
						<string>m&amp;m system loaded</string>
					</eventHandlerList>
					<Script isActive="yes" isFolder="no">
						<name>ndb.onshow</name>
						<packageName></packageName>
						<script>function ndb.onshow()
    local c = table.size(mm.me.highlightignore)

    mm.echofn("# of people on the highlightignore: %d ", c)

    setFgColor(unpack(mm.getDefaultColorNums))
    setUnderline(true)
    echoLink("(view)", 'echo"\\n" expandAlias"mmshow highlightignore"', 'Click here open the highlightignore list menu', true)
    echo"\n"
end</script>
						<eventHandlerList>
							<string>m&amp;m onshow</string>
						</eventHandlerList>
					</Script>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.loadsettings</name>
					<packageName></packageName>
					<script>function ndb.loadsettings()
  ndb.conf = ndb.conf or {}
  ndb.conf.orgpolitics = ndb.conf.orgpolitics or {}

  local conf_path = getMudletHomeDir() .. "/m&amp;m/namedb/orgpolitics"

  if lfs.attributes(conf_path) then
    table.load(conf_path, ndb.conf.orgpolitics)
  end

  -- setup defaults
  if next(ndb.conf.orgpolitics) then return end

  if mm.conf.org == "Magnagora" then
    ndb.conf.orgpolitics = {
      Magnagora = "ally", ["New Celest"] = "enemy", Hallifax = "neutral", Gaudiguch = "neutral", Glomdoring = "neutral", Serenwilde = "neutral"
    }
  elseif mm.conf.org == "New Celest"  then
    ndb.conf.orgpolitics = {
      Magnagora = "enemy", ["New Celest"] = "ally", Hallifax = "neutral", Gaudiguch = "enemy", Glomdoring = "enemy", Serenwilde = "neutral"
    }
  elseif mm.conf.org == "Hallifax"  then
    ndb.conf.orgpolitics = {
      Magnagora = "neutral", ["New Celest"] = "neutral", Hallifax = "ally", Gaudiguch = "neutral", Glomdoring = "neutral", Serenwilde = "neutral"
    }
  elseif mm.conf.org == "Gaudiguch"  then
    ndb.conf.orgpolitics = {
      Magnagora = "neutral", ["New Celest"] = "enemy", Hallifax = "enemy", Gaudiguch = "ally", Glomdoring = "ally", Serenwilde = "enemy"
    }
  elseif mm.conf.org == "Glomdoring"  then
    ndb.conf.orgpolitics = {
      Magnagora = "neutral", ["New Celest"] = "enemy", Hallifax = "neutral", Gaudiguch = "ally", Glomdoring = "ally", Serenwilde = "enemy"
    }
  elseif mm.conf.org == "Serenwilde"  then
    ndb.conf.orgpolitics = {
      Magnagora = "neutral", ["New Celest"] = "neutral", Hallifax = "neutral", Gaudiguch = "enemy", Glomdoring = "enemy", Serenwilde = "ally"
    }
  else
    ndb.conf.orgpolitics = {
      Magnagora = "neutral", ["New Celest"] = "neutral", Hallifax = "neutral", Gaudiguch = "neutral", Glomdoring = "neutral", Serenwilde = "neutral"
    }
  end
end</script>
					<eventHandlerList>
						<string>m&amp;m system loaded</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.fixes</name>
					<packageName></packageName>
					<script>function ndb.fixed_set(field, value, query)
   local db_name = field.database
   local s_name = field.sheet

   local conn = db.__conn[db_name]

   local sql_update = [[UPDATE OR %s %s SET "%s" = %s]]
   if query then
       sql_update = sql_update .. [[ WHERE %s]]
   end

   local sql = sql_update:format(db.__schema[db_name][s_name].options._violations, s_name, field.name, db:_coerce(field, value), query)

   db:echo_sql(sql)
   assert(conn:execute(sql))
   if db.__autocommit[db_name] then
      conn:commit()
   end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.close</name>
					<packageName></packageName>
					<script>function ndb.close()
  db:close()
  ioprint("ndb.close sysExitEvent")
end</script>
					<eventHandlerList>
						<string>sysExitEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getinfo</name>
					<packageName></packageName>
					<script>function ndb.download(name, reportback)
  assert(name)

  local name = name:title()
  ndb_reportnames = ndb_reportnames or {}
  ndb_reportnames[name] = reportback

  if not downloadFile then
    ((mm and mm.echof) or echo)("Your version of Mudlet doesn't support downloading files - please upgrade to 2.0+")
  else
    if not lfs.attributes(getMudletHomeDir().."/name downloads") then
		if lfs and lfs.mkdir then
         local t,s = lfs.mkdir(getMudletHomeDir().."/name downloads")
         if not t then ((mm and mm.echof) or echo)("Couldn't make the '"..getMudletHomeDir().."/name downloads/' folder; "..s) return end
		else
			((mm and mm.echof) or echo)("Sorry, but you need LuaFileSystem (lfs) installed, or have the '"..getMudletHomeDir().."/name downloads/' folder exist.")
			return
		end
    end

    downloadFile(getMudletHomeDir().."/name downloads/"..name, "http://www.ironrealms.com/game/honors/Lusternia/"..name);
    ((mm and mm.echof) or echo)("Retrieving information for "..name.."...")
  end
end

function ndb.download2(name, reportback)
  assert(name)

  local name = name:title()
  ndb_reportnames = ndb_reportnames or {}
  ndb_reportnames[name] = reportback

  if not downloadFile then
    ((mm and mm.echof) or echo)("Your version of Mudlet doesn't support downloading files - please upgrade to 2.0+")
  else
    if not lfs.attributes(getMudletHomeDir().."/name downloads") then
		if lfs and lfs.mkdir then
         local t,s = lfs.mkdir(getMudletHomeDir().."/name downloads")
         if not t then ((mm and mm.echof) or echo)("Couldn't make the '"..getMudletHomeDir().."/name downloads/' folder; "..s) return end
		else
			((mm and mm.echof) or echo)("Sorry, but you need LuaFileSystem (lfs) installed, or have the '"..getMudletHomeDir().."/name downloads/' folder exist.")
			return
		end
    end

    downloadFile(getMudletHomeDir().."/name downloads/"..name, "http://api.lusternia.com/characters/"..name:lower()..".json");
    if reportback then ((mm and mm.echof) or echo)("Retrieving information for "..name.."...") end
  end
end</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>ndb.download_done</name>
						<packageName></packageName>
						<script>function ndb.download_done(_, filepath)
  if not filepath:find("name downloads", 1, true) then return end

  io.input(filepath)
  local s = io.read("*a")

  -- didn't get JSON data? 
  if s:find("Internal error", 1, true) or s:find("DOCTYPE html PUBLIC", 1, true) then return end

  local t = yajl.to_value(s)

  local name = t.name

  -- don't record a name that's been deleted according to honors. the name still shows up on website.
  if ndb.deletednames and ndb.deletednames[name] then return end

  local guild = t.guild:title()
  local org = t.city:title()
--  local class = ndb.valid.guildtoclass[guild] -- Not anymore possible to determine class from guild
  local title = t.fullname

  if ndb_reportnames and ndb_reportnames[name] then
    local s = string.format("%s is a %s in %s", name, guild, org);
    ((mm and mm.echof) or echo)(s);
   ndb_reportnames[name] = nil
  end

  -- update data for DB, where "(none)" should be ""
  org = (org ~= "(none)" and org or "")
  -- change Celest to New Celest, the official title
  org = (org == "Celest" and "New Celest" or org)
  guild = (guild ~= "(none)" and guild or "")

  local temp_name_list = {{name = name, guild = guild, org = org, class = class, title = title}}

  db:merge_unique(ndb.db.people, temp_name_list)
  raiseEvent("NameDB saw list name", name)

--[[  if ndb.updatenames and next(ndb.updatenames) then
    ndb_download(table.remove(ndb.updatenames), true)
    if not next(ndb.updatenames) then
		ndb.db:_commit()
		ndb.db:_end()
	else
		mm.echof("%d left to check.", #ndb.updatenames)
	end
  end]]
  os.remove(filepath)
end</script>
						<eventHandlerList>
							<string>sysDownloadDone</string>
						</eventHandlerList>
					</Script>
				</Script>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>ndb.highlighter</name>
				<packageName></packageName>
				<script>function ndb.loadhighlights()
  ndb.highlightIDs = ndb.highlightIDs or {}
  collectgarbage("stop")

  ndb.cleartriggers()

  if mm.conf.ndbpaused then return end

  local highlight, watchfor = ndb.singlehighlight, mm.me.watchfor

  local dbnames = db:fetch(ndb.db.people)

  for i = 1, #dbnames do
    highlight(dbnames[i].name,
      dbnames[i].org or "",
      dbnames[i].order or "",
      dbnames[i].orgenemy or 0,
      dbnames[i].orderenemy or 0,
      dbnames[i].guildenemy or 0,
      watchfor[dbnames[i].name],
      dbnames[i].immortal or 0
    )
  end

  collectgarbage()
  raiseEvent("NameDB highlights reloaded")
end

function ndb.singlehighlight(name, org, order, orgenemy, orderenemy, guildenemy, watchfor, immortal)
  if ndb.highlightIDs and ndb.highlightIDs[name] then
    killTrigger(ndb.highlightIDs[name])
  end

  if name == mm.me.name or mm.me.highlightignore[name] or mm.conf.ndbpaused then return end

  local color, bold, underline, italicize
  local conf = mm.conf

  -- order of priority: watchfor &gt; divine &gt; org &gt; order &gt; guild &gt; citizens.

  org = org:lower():gsub(" ", "")
  if order == "" then order = false else order = order:lower() end

  -- color first
  if conf.highlightwatchfor and watchfor then
    color     = conf.watchforcolor or "a_darkwhite"

  elseif conf.highlightdivine and immortal == 1 then
    color     = conf.divinecolor or "a_darkwhite"

  elseif conf.highlightorg and orgenemy == 1 then
    color     = conf.orgcolor or "a_darkwhite"

  elseif conf.highlightorder and orderenemy == 1 then
    color     = conf.ordercolor or "a_darkwhite"

  elseif conf.highlightguild and guildenemy == 1 then
    color     = conf.guildcolor or "a_darkwhite"

  elseif order and conf["highlight"..order] then
    color     = conf[order.."color"] or "a_darkwhite"

  elseif org == "" and conf.highlightrogues then
    color     = conf.roguescolor or "a_darkwhite"

  elseif org and conf["highlight"..org] then
    color     = conf[org.."color"] or "a_darkwhite"
  end

  -- rest of things
  bold      = (conf.boldwatchfor and watchfor)            or
                (conf.boldorg and orgenemy == 1)          or
                (conf.boldorder and orderenemy == 1)      or
                (conf.boldguild and guildenemy == 1)      or
                (conf.bolddivine and immortal == 1)       or
                (order and conf["bold"..order])           or
                (org == "" and conf.boldrogues)           or
                (org and conf["bold"..org])

  underline = (conf.underlinewatchfor and watchfor)       or
                (conf.underlineorg and orgenemy == 1)     or
                (conf.underlineorder and orderenemy == 1) or
                (conf.underlineguild and guildenemy == 1) or
                (conf.underlinedivine and immortal == 1)  or
                (order and conf["underline"..order])      or
                (org == "" and conf.underlinerogues)      or
                (org and conf["underline"..org])

  italicize = (conf.italicizewatchfor and watchfor)       or
                (conf.italicizeorg and orgenemy == 1)     or
                (conf.italicizeorder and orderenemy == 1) or
                (conf.italicizeguild and guildenemy == 1) or
                (conf.italicizedivine and immortal == 1)  or
                (order and conf["italicize"..order])      or
                (org == "" and conf.italicizerogues)      or
                (org and conf["italicize"..org])

  if not (color or bold or underline or italicize) then return end

  ndb.highlightIDs = ndb.highlightIDs or {}
  ndb.highlightIDs[name] = tempTrigger(name, ([[ndb.highlight("%s", %s, %s, %s, %s)]]):format(name,
    (color     and '"'..color..'"' or "false"),
    (bold      and "true" or "false"),
    (underline and "true" or "false"),
    (italicize and "true" or "false")
  ))
end

function ndb.cleartriggers()
  if not ndb.highlightIDs or not next(ndb.highlightIDs) then return end

  local killTrigger = killTrigger
  for k,v in pairs(ndb.highlightIDs) do
    killTrigger(v)
  end

  ndb.highlightIDs = {}
end

function ndb.highlight(who, color, bold, underline, italicize)
	-- c counts the appearance of the substring of the word in the line, k counts the character position
	local c, k = 1, 1
	while k &gt; 0 do
		k = line:find(who, k)
		if k == nil then return; end
		c = c + 1

		if k == line:find("%f[%a]"..who.."%f[%A]", k) then
			if selectString(who, c-1) &gt; -1 then
				if color     then fg(color) end
				if bold      then setBold(true) end
				if underline then setUnderline(true) end
				if italicize then setItalics(true) end
				resetFormat()
			else return end
		end

--		k = k + #who
		k = k + 1
	end
end</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>ndb.loadhighlights</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList>
						<string>m&amp;m system loaded</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.addhighlightname</name>
					<packageName></packageName>
					<script>function ndb.addhighlightname(_, name)
  if not name then return end -- no name is passed on a suicided person

  local person = ndb.getname(name)

  if not person then return end -- in case a person was deleted

  ndb.singlehighlight(name,
      person.org or "",
      person.order or "",
      person.orgenemy or 0,
      person.orderenemy or 0,
      person.guildenemy or 0,
      mm.me.watchfor[person.name],
      person.immortal or 0)
end</script>
					<eventHandlerList>
						<string>NameDB finished honors</string>
						<string>m&amp;m watchfor name changed</string>
						<string>NameDB highlightignore name changed</string>
						<string>NameDB set name changed</string>
						<string>NameDB saw list name</string>
						<string>NameDB name deleted</string>
					</eventHandlerList>
				</Script>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>ndb.API</name>
				<packageName></packageName>
				<script>--ndb.API

function ndb.isglom(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.org, "Glomdoring"), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.ismag(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.org, "Magnagora"), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.iscelest(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.org, "New Celest"), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.ishalli(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.org, "Hallifax"), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.isgaudi(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.org, "Gaudiguch"), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.isseren(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.org, "Serenwilde"), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.isclass(name, class)
  name, class = name:title(), class:lower()
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.class, class), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.getclass(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return r[1].class:lower()
end

function ndb.setclass(name, class)
  class = class:lower()
  assert(ndb.isvalidclass(class), "ndb.setclass: invalid class given")

  ndb.fixed_set(ndb.db.people.class, class, db:eq(ndb.db.people.name, name))
end

function ndb.getorg(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return r[1].org
end

function ndb.getguild(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return r[1].guild:lower()
end

function ndb.getguild_shortname(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return ndb.valid.guildtoshort[r[1].guild:title()]
end

function ndb.getnotes(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return r[1].notes
end

function ndb.isdemigod(name)
  assert(name, "ndb.isdemigod() requires a name")

  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return (r[1].demigod == 1 and true or false)
end

function ndb.setdemigod(name, status)
  status = mm.toboolean(status) and 1 or 0

  ndb.fixed_set(ndb.db.people.demigod, status, db:eq(ndb.db.people.name, name))
end

function ndb.isimmortal(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return (r[1].immortal == 1 and true or false)
end

function ndb.exists(name)
  return #(db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))) ~= 0
end

function ndb.isperson(name)
  return #(db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))) ~= 0
end

-- returns true only if a certain enemy
function ndb.isenemy(name)
  local p = ndb.getname(name)
  if not p then return false end

  local org = p.org

  -- -1 autodetected, 1 enemy, 2 ally
  if p.iff == 1 or
       (p.iff ~= 2 and (org and org ~= "" and ndb.conf.orgpolitics[org] ~= "ally") and
         ((org and org ~= "" and ndb.conf.orgpolitics[org] == "enemy") or
         (p.orgenemy == 1 or p.orderenemy == 1 or p.guildenemy == 1))
       )
  then
    return true else return false
  end
end

-- returns true only if someone is an enemy via iff or is a org enemy. They could be a guild enemy, and not be considered an enemy by this
function ndb.isorgenemy(name)
  local p = ndb.getname(name)
  if not p then return false end

  local org = p.org

  -- -1 autodetected, 1 enemy, 2 ally
  if p.iff == 1 or
       (p.iff ~= 2 and
         ((org and org ~= "" and ndb.conf.orgpolitics[org] == "enemy") or
         (p.orgenemy == 1))) then
    return true else return false
  end
end

-- given a title, returns all info about a person
function ndb.getnamebytitle (title)
  return db:fetch(ndb.db.people, db:in_(ndb.db.people.name, string.split(title, " ")))
end

-- given a line, returns the first name it finds, if any
function ndb.findname(line)
  for w in string.gmatch(line, "(%u%l+)") do
    if #w &gt;= 3 then
      if ndb.isperson(w) then return w end
    end
  end
end

-- given a line, returns all names found on it
function ndb.findnames(line)
  local l = {}
  for w in string.gmatch(line, "(%u%l+)") do
    if #w &gt;= 3 then
      if ndb.isperson(w) then l[#l+1] = w end
    end
  end

  if l[1] then return l end
end

-- given a name, returns all info about a person
function ndb.getname (name)
  return db:fetch(ndb.db.people, db:eq(ndb.db.people.name, string.title(name)))[1]
end

--  "Magnagora", "New Celest", "Hallifax", "Gaudiguch", "Glomdoring", "Serenwilde"
local singular_org = {
  [""]           = "Rogue",
  ["New Celest"] = "Celestian",
  Gaudiguch      = "Gaudi",
  Glomdoring     = "Glom",
  Hallifax       = "Halli",
  Magnagora      = "Mag",
  Serenwilde     = "Seren"
}

local plural_org = {
  [""]           = "Rogues",
  ["New Celest"] = "Celestians",
  Gaudiguch      = "Gaudis",
  Glomdoring     = "Gloms",
  Hallifax       = "Hallis",
  Magnagora      = "Mags",
  Serenwilde     = "Serens"
}

local singular_class = {}

local plural_class = {
  ["aeromancer"]   = "aeromancers",
  ["aquamancer"]   = "aquamancers",
  ["blacktalon"]   = "blacktalon",
  ["cacophonist"]  = "cacophony",
  ["cantor"]       = "cantors",
  ["celestine"]    = "celestines",
  ["ebonguard"]    = "ebonguard",
  ["geomancer"]    = "geomancers",
  ["harbinger"]    = "harbingers",
  ["hartstone"]    = "hartstone",
  ["illuminati"]   = "illuminati",
  ["researcher"]   = "researchers",
  ["minstrel"]     = "minstrels",
  ["moondancer"]   = "moondancers",
  ["nekotai"]      = "nekotai",
  ["nihilist"]     = "nihilists",
  ["ninjakari"]    = "ninjakari",
  ["paladin"]      = "paladins",
  ["pyromancer"]   = "pyromancers",
  ["sentinel"]     = "sentinels",
  ["serenguard"]   = "serenguards",
  ["shadowdancer"] = "shadowdancers",
  ["shofangi"]     = "shofangi",
  ["spiritsinger"] = "spiritsingers",
  ["symphonist"]   = "symphonists",
  ["tahtetso"]     = "tahtetso",
  ["templar"]      = "templars",
  ["ur'guard"]     = "ur'guards",
}

local contains = table.contains
for class in pairs(plural_class) do if not table.contains(ndb.valid.classes, class) then mm.echof("Warning: %s as defined in plural_class is missing from ndb.valid.classes. Seems like a mistake?") end end

function ndb.getpluralclass(class, count)
  class = class:lower()
  if count &lt;= 1 then
    return class
  else
    return plural_class[class]
  end
end

function ndb.getpluralorg(org, count)
  if count &lt;= 1 then
    return singular_org[org]
  else
    return plural_org[org]
  end
end

function ndb.getcolor(name)
  assert(type(name) == "string", "ndb.getcolor: name to get a color of is required")

  local person = ndb.getname(name)

  if not person then return "" end -- in case the person doesn't exist

  local city, conf, color = person.org, mm.conf

  -- order of priority: watchfor &gt; divine &gt; city &gt; order &gt; house &gt; citizens.  
  if city == "" or not city then city = false else city = city:lower() end -- known rogues are returned as ""
  if city == "new celest" then city = "newcelest" end

  -- color first
  if conf.highlightwatchfor and mm.me.watchfor[name] then
    color     = conf.watchforcolor or "a_darkwhite"

  elseif conf.highlightdivine and person.immortal == 1 then
    color     = conf.divinecolor or "a_darkwhite"

  elseif conf.highlightcity and person.cityenemy == 1 then
    color     = conf.citycolor or "a_darkwhite"

  elseif conf.highlightorder and person.orderenemy == 1 then
    color     = conf.ordercolor or "a_darkwhite"

  elseif conf.highlighthouse and person.houseenemy == 1 then
    color     = conf.housecolor or "a_darkwhite"

  elseif order and conf["highlight"..order] then
    color     = conf[order.."color"] or "a_darkwhite"

  elseif city and conf["highlight"..city] then
    color     = conf[city.."color"] or "a_darkwhite"
  end

  return (color and '&lt;'..color..'&gt;' or "")
end

function ndb.getcolorp(name)
  assert(type(name) == "string", "ndb.getcolor: name to get a color of is required")

  local person = ndb.getname(name)

  if not person then return "" end -- in case the person doesn't exist

  local city, conf, color = person.org, mm.conf

  -- order of priority: watchfor &gt; divine &gt; city &gt; order &gt; house &gt; citizens.  
  if city == "" then city = false else city = city:lower() end -- known rogues are returned as ""

  -- color first
  if conf.highlightwatchfor and mm.me.watchfor[name] then
    color     = conf.watchforcolor or "a_darkwhite"

  elseif conf.highlightdivine and person.immortal == 1 then
    color     = conf.divinecolor or "a_darkwhite"

  elseif conf.highlightcity and person.cityenemy == 1 then
    color     = conf.citycolor or "a_darkwhite"

  elseif conf.highlightorder and person.orderenemy == 1 then
    color     = conf.ordercolor or "a_darkwhite"

  elseif conf.highlighthouse and person.houseenemy == 1 then
    color     = conf.housecolor or "a_darkwhite"

  elseif order and conf["highlight"..order] then
    color     = conf[order.."color"] or "a_darkwhite"

  elseif city and conf["highlight"..city] then
    color     = conf[city.."color"] or "a_darkwhite"
  end

  return color
end

for _, format in ipairs{"bold", "underline", "italicize"} do
  ndb["should"..format] = function(name)
    assert(type(name) == "string", "ndb.should"..format..": name to get a color of is required")

    local person = ndb.getname(name)

    if not person then return false end -- in case the person doesn't exist

    local city, conf, color = person.org, mm.conf

    return (conf[format.."watchfor"] and mm.me.watchfor[name])    or 
           (conf[format.."city"] and person.cityenemy == 1)        or
           (conf[format.."order"] and person.orderenemy == 1)      or
           (conf[format.."house"] and person.houseenemy == 1)      or
           (conf[format.."divine"] and person.immortal == 1)       or
           (order and conf[format..order])                         or
           (city == "" and conf[format.."rogues"])                 or
           (city and conf[format..city])
  end
end

function ndb.addname(name)
  local temp_name_list = {}

  if type(name) == "table" then
    for i = 1, #name do
      temp_name_list[#temp_name_list+1] = {name = name[i]:title()}
    end
  else
    temp_name_list = {{name = name:title()}}
  end

  db:merge_unique(ndb.db.people, temp_name_list)

  raiseEvent("NameDB got new data")
end

function ndb.setiff(name, status)
  local name = name:lower():title()

  local category = "iff"
  local towhat

  -- -1 autodetected, 1 enemy, 2 ally
  local status = status:lower()
  if status == "enemy" then
    towhat = 1
  elseif status == "ally" then
    towhat = 2
  else
    towhat = -1
  end

  local temp_name_list = {{
    name = name,
    [category] = towhat
  }}

  db:merge_unique(ndb.db.people, temp_name_list)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>ndb.aliases</name>
				<packageName></packageName>
				<script>function ndb.showwhois(whom)
  local data = ndb.getname(whom)

  if not data then mm.echof("I'm afraid we don't know person named %s.", matches[2]:title()) mm.showprompt() return end

  if data.immortal == 0 then
    cecho("\n&lt;a_darkblue&gt;--&lt;purple&gt;(m&amp;m) &lt;a_grey&gt;"..data.name.."'s ("..data.gender:sub(1,1)..") NameDB profile&lt;a_darkblue&gt;" .. ("-"):rep(55-#data.name) .. "\n")
    cecho("&lt;a_darkcyan&gt;  Orgs:\n")
    cecho(string.format("&lt;a_darkgrey&gt;    Guild: %-23s Org:        %s (cr%s)\n",
      (data.guild == '' and 'unknown' or data.guild),
      (data.org == '' and 'unknown' or data.org),
      (data.org_rank == 0 and '?' or data.org_rank)
    ))

    cecho(string.format("&lt;a_darkgrey&gt;    Order: %s\n",
      (data.order == '' and 'unknown' or data.order)
    ))

    cecho("\n&lt;a_darkcyan&gt;  Personal:\n")
    cecho(string.format("&lt;a_darkgrey&gt;    Class:  %-15s        XP rank:    %s\n",
      (data.class == '' and 'unknown' or data.class),
      (data.xp_rank == -2 and 'unranked' or (data.xp_rank == -1 and 'unknown' or data.xp_rank))
    ))
    cecho(string.format("&lt;a_darkgrey&gt;    Might:  %-10s             Importance: %s\n",
      (data.might == -1 and 'unranked' or data.might),
      (data.importance == 0 and 'unset' or data.importance)
    ))
    cecho(string.format("&lt;a_darkgrey&gt;    Demigod: %-9s             Race:       %s\n",
      (data.demigod == 1 and 'yep' or 'nope'),
      (data.race == '' and 'unknown' or data.race)
    ))
    cecho(string.format("&lt;a_darkgrey&gt;    Has laurels: %s\n",
      (data.laurels == 1 and 'yep' or 'nope')
    ))

    cecho("\n&lt;a_darkcyan&gt;  Status to you:\n")
    cecho(string.format("&lt;a_darkgrey&gt;    Org enemy:   %-10s        Guild enemy: %s\n",
      (data.orgenemy == 0 and 'nope' or 'yep'),
      (data.guildenemy == 0 and 'nope' or 'yep')
    ))

    cecho(string.format("&lt;a_darkgrey&gt;    Order enemy: %-11s       \n",
      data.orderenemy == 0 and 'nope' or 'yep'
    ))

    local currenstatus
    if data.iff == -1 then
      if ndb.isenemy(data.name) then currenstatus = "enemy (auto)"
      else currenstatus = "ally (auto)" end
    end

    cecho(string.format("&lt;a_darkgrey&gt;    Actual status to you: %s\n",
      (data.iff == -1 and currenstatus or (data.iff == 1 and "enemy (manual)" or "ally (manual)"))
    ))
  else
    cecho("\n&lt;a_darkblue&gt;--&lt;purple&gt;(m&amp;m) &lt;a_grey&gt;"..data.name.."'s NameDB profile&lt;a_darkblue&gt;" .. ("-"):rep(55-#data.name) .. "\n")
    cecho("\n&lt;a_darkcyan&gt;    They are an Immortal.\n")
  end

  cecho("\n&lt;a_darkcyan&gt;  Notes (")
  setUnderline(true)
  fg("a_darkcyan")
  echoLink("edit", 'printCmdLine"ndb set '..whom:title()..' notes '..data.notes:gsub("\n", [[\\n]])..'"', 'Click to edit the notes you have on '..whom:title()..' - you can use \\n for a linebreak, and &lt;color&gt; to color text', true)
  resetFormat()
  cecho("&lt;a_darkcyan&gt;):\n")
  cecho(string.format("    &lt;a_blue&gt;- &lt;a_grey&gt;"..((data.notes and data.notes ~= "") and data.notes:gsub("\n", "\n    &lt;a_blue&gt;-&lt;reset&gt; ") or "none yet").."\n"))
  deselect() fg("a_darkblue") echo(string.rep("-", 80)) resetFormat() echo'\n'
  mm.showprompt()
end

function ndb.exportmenu()
  mm.echof("Exporting works in 3 steps:\n")

  setFgColor(unpack(mm.getDefaultColorNums))
  echo("a) select what data about people you'd like to export:\n")
  for key, _ in pairs(ndb.exportdata.fields) do
    echo("  ")

    if key == "name" then
      echoLink("[X] name", [[mm.echof("The name has to stay, otherwise what'll be there to import?")]], "If you'd just like to share the list of names known, you can tick everything else off and leave this on", true)
    else
      echoLink("["..(ndb.exportdata.fields[key] and 'X' or ' ')..'] '..key,
        [[ndb.exportdata.fields.]]..key..[[ = ]]..tostring(not ndb.exportdata.fields[key])..[[;ndb.exportmenu()]],
        'Click to '..(not ndb.exportdata.fields[key] and 'add' or 'remove') .. ' '..key .. ' for export', true)
    end
    echo("\n")
  end

  echo("\n")
  echo("b) select which people you'd like to export:\n")
  for key, _ in pairs(ndb.exportdata.people) do
    setFgColor(unpack(mm.getDefaultColorNums))
    echo("  ")

    echoLink("["..(ndb.exportdata.people[key] and 'X' or ' ')..'] '..key,
      [[ndb.exportdata.people.]]..key..[[ = ]]..tostring(not ndb.exportdata.people[key])..[[;ndb.exportmenu()]],
      (ndb.exportdata.people[key] and 'Click to export '..key or 'Click not to export '..key), true)

    echo("\n")
  end

  echo("\n")
  echo("d) select a folder to export to: ")
  setUnderline(true)
  echoLink((not ndb.exportdata.location and "&lt;folder&gt;" or ndb.exportdata.location), [[
    ndb.exportdata.location = invokeFileDialog(false, "Where do you want to save the file? Select it and click Open")
    if ndb.exportdata.location == "" then ndb.exportdata.location = false end
    ndb.exportmenu()]],
    '', true)
  setUnderline(false)
  echo("\n")

  echo("\n")
  mm.echofn("All set? ")

  setUnderline(true)
  setFgColor(unpack(mm.getDefaultColorNums))
  echoLink("Export!", (not ndb.exportdata.location and 'mm.echof("Pick a folder to export to, silly.")' or 'ndb.doexport()'), 'Click to export', true)
  setUnderline(false)
end

function ndb.importmenu()
  mm.echof("Import NameDB data:")

  setFgColor(unpack(mm.getDefaultColorNums))
  echo("\n")
  if not ndb.importdata.location then echo("a) select a file to import: ") else echo("a) file to import: ") end
  setUnderline(true)
  echoLink((not ndb.importdata.location and "&lt;file&gt;" or ndb.importdata.location), [[
    ndb.importdata.location = invokeFileDialog(true, "Pick the file you'd like to import and select Open")
    if ndb.importdata.location == "" then ndb.importdata.location = false end
    if ndb.importdata.location then ndb.getimportfields() end
    ndb.importmenu()]],
    '', true)
  setUnderline(false)
  echo("\n")

  echo("\n")
  if not ndb.importdata.data then
    echo("b) select which fields to import once you've picked a file")
  else
    echo("b) select which fields to import:\n")
    for key, _ in pairs(ndb.importdata.fields) do
      echo("  ")

      if key == "name" then
        echoLink("[X] name", [[mm.echof("The name has to stay, otherwise how will the import data make sense?")]], "The persons name - this has to stay", true)
      else
        echoLink("["..(ndb.importdata.fields[key] and 'X' or ' ')..'] '..key,
          [[ndb.importdata.fields.]]..key..[[ = ]]..tostring(not ndb.importdata.fields[key])..[[;ndb.importmenu()]],
          'Click to '..(not ndb.importdata.fields[key] and 'add' or 'remove') .. ' '..key .. ' for import', true)
      end
      echo("\n")
    end
  end
  echo("\n")

  echo("\n")
  mm.echofn("All set? ")

  setUnderline(true)
  setFgColor(unpack(mm.getDefaultColorNums))
  echoLink("Import!", (not ndb.importdata.data and 'mm.echof("Pick a file to import first!")' or 'ndb.doimport()'), 'Click to import', true)
  setUnderline(false)
  echo("\n")
end

function ndb.checkqw(suffix, how)
  if ndb.qwtimer then killTimer(ndb.qwtimer) end

  enableTrigger("NameDB qw")
  ndb.qwtimer = tempTimer(3, function() disableTrigger("NameDB qw"); ndb.qwtimer = nil end)
  ndb.qwtype = how

  send("qw"..(suffix and suffix or ''), false)
end</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Third-party</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Pluralization</name>
					<packageName></packageName>
					<script>--
-- MySQL Workbench Doctrine Export Plugin
-- Version: 0.3.6
-- Authors: Johannes Mueller, Karsten Wutzke
-- Copyright (c) 2008-2009
--
-- http://code.google.com/p/mysql-workbench-doctrine-plugin/
--
-- This file is free software: you can redistribute it and/or
-- modify it under the terms of the GNU Lesser General Public
-- License as published by the Free Software Foundation, either
-- version 3 of the License, or (at your option) any later version.
--
-- This library is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-- Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public
-- License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
--

function string.endswith(s, suffix)
    return s:sub(#s - #suffix + 1) == suffix
end

function isPlural(s)
    -- is plural if string ends with an "s" but not with "ss"
    return string.endswith(s, "s") and not string.endswith(s, "ss") and #s &gt; 1
end

function isSingular(s)
    -- is singular if not plural
    return not isPlural(s)
end

function string.singularize(s)

    -- is plural?
    if ( isPlural(s) ) then
        -- strip "s"
        s = string.sub(s, 1, #s - 1)

        -- we can't just strip the s without looking at the remaining English plural endings
        -- see http://en.wikipedia.org/wiki/English_plural

        -- if the table name ends with "e" ("coache", "hashe", "addresse", "buzze", "heroe", ...)
        if (    string.endswith(s, "che")
             or string.endswith(s, "she")
             or string.endswith(s, "sse")
             or string.endswith(s, "zze")
             or string.endswith(s, "oe") ) then

            -- strip an "e", too
            s = string.sub(s, 1, #s - 1)

        -- if table name ends with "ie"
        elseif ( string.endswith(s, "ie") ) then
            -- replace "ie" by a "y" ("countrie" -&gt; "country", "hobbie" -&gt; "hobby", ...)
            s = string.sub(s, 1, #s - 2) .. "y"

        elseif ( string.endswith(s, "ve") ) then
            -- replace "ve" by an "f" ("calve" -&gt; "calf", "leave" -&gt; "leaf", ...)
            s = string.sub(s, 1, #s - 2) .. "f"

            -- does *not* work for certain words ("knive" -&gt; "knif", "stave" -&gt; "staf", ...): TODO (hard)
        else
            -- do nothing ("game", "referee", "monkey", ...)

            -- note: table names like "Caches" can't be handled correctly because of the "che" rule above,
            -- that word however basically stems from French and might be considered a special case anyway
            -- also collective names like "Personnel", "Cast" (caution: SQL keyword!) can't be singularized
        end
    end

    return s
end

function string.pluralize(s)

    -- is singular?
    if ( isSingular(s) ) then

        -- we can't just append the s without looking at the English singular endings
        -- see http://en.wikipedia.org/wiki/English_plural

        -- if the table name ends with "ch", "sh", "ss" or "zz" ("coach", "hash", "address", "buzz", "hero", ...)
        if (    string.endswith(s, "ch")
             or string.endswith(s, "sh")
             or string.endswith(s, "ss")
             or string.endswith(s, "zz")
             or string.endswith(s, "o") ) then

            -- append "es"
            s = s .. "es"

        -- if table name ends with "y"
        elseif ( string.endswith(s, "y") ) then
            -- replace "y" with "ies" ("country" -&gt; "countries", "hobby" -&gt; "hobbies", ...)
            s = string.sub(s, 1, #s - 1) .. "ies"

        elseif ( string.endswith(s, "f") ) then
            -- replace "f" by an "ves" ("leaf" -&gt; "leaves", "half" -&gt; "halves", ...)
            s = string.sub(s, 1, #s - 1) .. "ves"
        else
            -- append "s" ("games", "referees", "monkeys", ...)
            s = s .. "s"
        end
    end

    return s
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Ordinal</name>
					<packageName></packageName>
					<script>function string.ordinalSuffix (n)
  n = math.mod (n, 100)
  local d = math.mod (n, 10)
  if d == 1 and n ~= 11 then
    return "st"
  elseif d == 2 and n ~= 12 then
    return "nd"
  elseif d == 3 and n ~= 13 then
    return "rd"
  else
    return "th"
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Stats</name>
					<packageName></packageName>
					<script>-- Small stats library                      --
----------------------------------------------
-- Version History --
-- 1.0 First written.

-- Tables supplied as arguments are not changed.


-- Table to hold statistical functions
stats={}

-- Get the mean value of a table
function stats.mean( t )
  local sum = 0
  local count = 0
  local type = type

  for k,v in pairs(t) do
    if type(v) == 'number' then
      sum = sum + v
      count = count + 1
    end
  end

  return (sum / count)
end

-- Get the mode of a table.  Returns a table of values.
-- Works on anything (not just numbers).
function stats.mode( t )
  local counts={}

  for k, v in pairs( t ) do
    if counts[v] == nil then
      counts[v] = 1
    else
      counts[v] = counts[v] + 1
    end
  end

  local biggestCount = 0

  for k, v  in pairs( counts ) do
    if v &gt; biggestCount then
      biggestCount = v
    end
  end

  local temp={}

  for k,v in pairs( counts ) do
    if v == biggestCount then
      table.insert( temp, k )
    end
  end

  return temp
end

-- Get the median of a table.
function stats.median( t )
  local temp={}

  -- deep copy table so that when we sort it, the original is unchanged
  -- also weed out any non numbers
  for k,v in pairs(t) do
    if type(v) == 'number' then
      table.insert( temp, v )
    end
  end

  table.sort( temp )

  -- If we have an even number of table elements or odd.
  if math.fmod(#temp,2) == 0 then
    -- return mean value of middle two elements
    return ( temp[#temp/2] + temp[(#temp/2)+1] ) / 2
  else
    -- return middle element
    return temp[math.ceil(#temp/2)]
  end
end


-- Get the standard deviation of a table
function stats.standardDeviation( t )
  local m
  local vm
  local sum = 0
  local count = 0
  local result

  m = stats.mean( t )

  for k,v in pairs(t) do
    if type(v) == 'number' then
      vm = v - m
      sum = sum + (vm * vm)
      count = count + 1
    end
  end

  result = math.sqrt(sum / (count-1))

  return result
end

-- Get the max and min for a table
function stats.maxmin( t )
  local max = -math.huge
  local min = math.huge

  for k,v in pairs( t ) do
    if type(v) == 'number' then
      max = math.max( max, v )
      min = math.min( min, v )
    end
  end

  return max, min
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
